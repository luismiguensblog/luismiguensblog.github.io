<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="author" content="">
<meta name="description" content="Background: Templates in C&#43;&#43;11/14 and the Need for Change Prior to C&#43;&#43;17, when using class templates in C&#43;&#43;, developers had to explicitly specify all template arguments for the class. The compiler did not deduce class template parameters from constructor arguments as it did for function templates. For example, constructing a std::pair of two int values required writing std::pair&lt;int, int&gt; p(11, 22); – even though the compiler “already knows” the types of 11 and 22 are int. In contrast, function templates benefited from template argument deduction since C&#43;&#43;98: given a function template like sort(RanIt first, RanIt last), the compiler can deduce the iterator type from the call sort(v.begin(), v.end()); without explicit template arguments. This discrepancy meant extra verbosity for class templates and led to workarounds.
" />
<meta name="keywords" content=", c_cpp, programming" />
<meta name="robots" content="noodp" />
<meta name="theme-color" content="" />
<link rel="canonical" href="https://blog.miguens.one/posts/2025/06/template-argument-deduction-for-class-templates-in-c-17/" />


    <title>
        
            Template Argument Deduction for Class Templates in C&#43;&#43;17 :: Luis Miguens Blog 
        
    </title>





  <link rel="stylesheet" href="https://blog.miguens.one/main.min.07ea7ac7da67e2e153a7dfa2457bc6a19cca824288d175e223fadc579041bc51.css" integrity="sha256-B&#43;p6x9pn4uFTp9&#43;iRXvGoZzKgkKI0XXiI/rcV5BBvFE=" crossorigin="anonymous">





    <link rel="apple-touch-icon" sizes="180x180" href="https://blog.miguens.one/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="https://blog.miguens.one/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="https://blog.miguens.one/favicon-16x16.png">
    <link rel="manifest" href="https://blog.miguens.one/site.webmanifest">
    <link rel="mask-icon" href="https://blog.miguens.one/safari-pinned-tab.svg" color="">
    <link rel="shortcut icon" href="https://blog.miguens.one/favicon.ico">
    <meta name="msapplication-TileColor" content="">



  <meta itemprop="name" content="Template Argument Deduction for Class Templates in C&#43;&#43;17">
  <meta itemprop="description" content="Background: Templates in C&#43;&#43;11/14 and the Need for Change Prior to C&#43;&#43;17, when using class templates in C&#43;&#43;, developers had to explicitly specify all template arguments for the class. The compiler did not deduce class template parameters from constructor arguments as it did for function templates. For example, constructing a std::pair of two int values required writing std::pair&lt;int, int&gt; p(11, 22); – even though the compiler “already knows” the types of 11 and 22 are int. In contrast, function templates benefited from template argument deduction since C&#43;&#43;98: given a function template like sort(RanIt first, RanIt last), the compiler can deduce the iterator type from the call sort(v.begin(), v.end()); without explicit template arguments. This discrepancy meant extra verbosity for class templates and led to workarounds.">
  <meta itemprop="datePublished" content="2025-06-26T00:00:00+00:00">
  <meta itemprop="dateModified" content="2025-06-26T00:00:00+00:00">
  <meta itemprop="wordCount" content="2972">
  <meta itemprop="image" content="https://blog.miguens.one/">
  <meta itemprop="keywords" content="C_cpp,Programming">

  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:image" content="https://blog.miguens.one/">
  <meta name="twitter:title" content="Template Argument Deduction for Class Templates in C&#43;&#43;17">
  <meta name="twitter:description" content="Background: Templates in C&#43;&#43;11/14 and the Need for Change Prior to C&#43;&#43;17, when using class templates in C&#43;&#43;, developers had to explicitly specify all template arguments for the class. The compiler did not deduce class template parameters from constructor arguments as it did for function templates. For example, constructing a std::pair of two int values required writing std::pair&lt;int, int&gt; p(11, 22); – even though the compiler “already knows” the types of 11 and 22 are int. In contrast, function templates benefited from template argument deduction since C&#43;&#43;98: given a function template like sort(RanIt first, RanIt last), the compiler can deduce the iterator type from the call sort(v.begin(), v.end()); without explicit template arguments. This discrepancy meant extra verbosity for class templates and led to workarounds.">



    <meta property="og:url" content="https://blog.miguens.one/posts/2025/06/template-argument-deduction-for-class-templates-in-c-17/">
  <meta property="og:site_name" content="Luis Miguens Blog">
  <meta property="og:title" content="Template Argument Deduction for Class Templates in C&#43;&#43;17">
  <meta property="og:description" content="Background: Templates in C&#43;&#43;11/14 and the Need for Change Prior to C&#43;&#43;17, when using class templates in C&#43;&#43;, developers had to explicitly specify all template arguments for the class. The compiler did not deduce class template parameters from constructor arguments as it did for function templates. For example, constructing a std::pair of two int values required writing std::pair&lt;int, int&gt; p(11, 22); – even though the compiler “already knows” the types of 11 and 22 are int. In contrast, function templates benefited from template argument deduction since C&#43;&#43;98: given a function template like sort(RanIt first, RanIt last), the compiler can deduce the iterator type from the call sort(v.begin(), v.end()); without explicit template arguments. This discrepancy meant extra verbosity for class templates and led to workarounds.">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-06-26T00:00:00+00:00">
    <meta property="article:modified_time" content="2025-06-26T00:00:00+00:00">
    <meta property="article:tag" content="C_cpp">
    <meta property="article:tag" content="Programming">
    <meta property="og:image" content="https://blog.miguens.one/">




    <meta property="article:section" content="technical" />



    <meta property="article:published_time" content="2025-06-26 00:00:00 &#43;0000 UTC" />









    
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-ZHDRD7M8H9"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-ZHDRD7M8H9');
        }
      </script>



    </head>

    
        <body>
    
    
        <div class="container">
            <header class="header">
    <span class="header__inner">
        <a href="https://blog.miguens.one/" style="text-decoration: none;">
    <div class="logo">
        
            <span class="logo__mark">&gt;</span>
            <span class="logo__text ">
                $ cd /home/</span>
            <span class="logo__cursor" style=
                  "
                   
                   ">
            </span>
        
    </div>
</a>


        <span class="header__right">
                <nav class="menu">
    <ul class="menu__inner"><li><a href="https://blog.miguens.one/about/">About</a></li><li><a href="https://blog.miguens.one/categories/">Categories</a></li><li><a href="https://blog.miguens.one/posts/">Posts</a></li>
    </ul>
</nav>

                <span class="menu-trigger">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                        <path d="M0 0h24v24H0z" fill="none"/>
                        <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
                    </svg>
                </span>
        </span>
    </span>
</header>


            <div class="content">
                
  <main class="post">

    <div class="post-info">
      <p>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock">
          <circle cx="12" cy="12" r="10"></circle>
          <polyline points="12 6 12 12 16 14"></polyline>
        </svg>
        14 minutes

        
      </p>
    </div>

    <article>
      <h1 class="post-title">
        <a href="https://blog.miguens.one/posts/2025/06/template-argument-deduction-for-class-templates-in-c-17/">Template Argument Deduction for Class Templates in C++17</a>
      </h1>

      

      

      

      <div class="post-content">
        <h2 id="background-templates-in-c1114-and-the-need-for-change">Background: Templates in C++11/14 and the Need for Change</h2>
<p>Prior to C++17, when using class templates in C++, developers had to explicitly specify all template arguments for the class. The compiler did not deduce class template parameters from constructor arguments as it did for function templates. For example, constructing a <code>std::pair</code> of two <code>int</code> values required writing <code>std::pair&lt;int, int&gt; p(11, 22);</code> – even though the compiler “already knows” the types of <code>11</code> and <code>22</code> are <code>int</code>. In contrast, function templates benefited from <em>template argument deduction</em> since C++98: given a function template like <code>sort(RanIt first, RanIt last)</code>, the compiler can deduce the iterator type from the call <code>sort(v.begin(), v.end());</code> without explicit template arguments. This discrepancy meant extra verbosity for class templates and led to <em>workarounds</em>.</p>
<p>To mitigate this, C++11/14 code often relied on helper factory functions (e.g. <code>std::make_pair</code>, <code>std::make_tuple</code>, <code>std::make_unique</code>) which are function templates that deduce the desired class template types and return an object. For instance, instead of specifying the template parameters for a <code>pair</code>, one could write <code>auto p = std::make_pair(11, 22);</code> to get a <code>std::pair&lt;int, int&gt;</code> without spelling out the types. While effective, these helper functions had drawbacks: they introduced extra indirection and template machinery (e.g. perfect forwarding and type decay in <code>std::make_pair</code>), incurred minor compile-time and debugging overhead (the compiler must instantiate and then optimize away the helper) and still added verbosity (the <code>make_...</code> prefix or the need for <code>auto</code> for a named variable). In summary, before C++17 <strong>class templates could not deduce their template arguments</strong> from constructor calls, making generic code more cumbersome than necessary.</p>
<h2 id="c17-introducing-class-template-argument-deduction-ctad">C++17: Introducing Class Template Argument Deduction (CTAD)</h2>
<p>C++17 addressed this longstanding issue by introducing <em>class template argument deduction</em> (CTAD) as a core language feature. In essence, the compiler can now deduce the template parameters of a class template from the constructor arguments, <strong>provided no explicit template argument list is given</strong>. This feature allows class templates to be used in a more intuitive way, similar to how function templates have always been used. <strong>C++17 allows you to simply write the class template name and initializer, and the compiler deduces the template arguments automatically</strong>. For example, one can now write <code>std::pair(11, 22)</code> instead of <code>std::pair&lt;int, int&gt;(11, 22)</code> – the two are equivalent in C++17. In other words, given only the class template name and constructor call, the compiler will determine that <code>11</code> and <code>22</code> are <code>int</code> and instantiate a <code>std::pair&lt;int, int&gt;</code> accordingly. This significantly reduces verbosity and improves code clarity.</p>
<p>So how does CTAD work? Under the hood, the compiler uses the types of constructor arguments to deduce the template parameters. Formally, when you create an object with a class template name and no <code>&lt;…&gt;</code> list, the compiler imagines a set of <em>fictional function templates</em> corresponding to each constructor of the class template. It then uses template argument deduction (as it would for function templates) to find which “constructor template” matches the given arguments and infers the template arguments for the class. In practice, you don’t see this process – you just get the instantiated class. The key point is that every template parameter must be deduced or have a default; if any template argument remains unknown and has no default, deduction will fail and the code won’t compile. Notably, if you <em>do</em> provide an explicit template argument list (even if partial), CTAD is disabled entirely. This means you cannot explicitly specify <em>some</em> template arguments and have the rest deduced in C++17 – it’s all-or-nothing deduction for class templates.</p>
<p><strong>Deduction Guides:</strong> In most cases, CTAD “just works” using constructors. However, there are scenarios where the compiler needs a bit of help. A <em>deduction guide</em> is a new C++17 mechanism that lets developers explicitly instruct the compiler how to deduce template parameters for certain argument patterns. The syntax resembles a function declaration with a trailing <code>-&gt;</code> return type indicating the class specialization to instantiate. <em>Implicit deduction guides</em> are automatically generated from constructors (including templated constructors) of the class template. In addition, developers can write <em>user-defined deduction guides</em> to handle special cases or improve deduction where the implicit rules don’t suffice. A deduction guide is essentially a hint to the compiler: “if you see a constructor call with parameters of types X, Y, …, then deduce the template arguments as T…, and instantiate <code>Class&lt;T...&gt;</code>”.</p>
<p>Why might we need user-defined guides? One common case in C++17 is <strong>class templates that are <em>aggregates</em></strong> (structs or classes with public data members and no user-defined constructors). Aggregates don’t have constructors for the compiler to examine, so the language cannot deduce their template parameters from initializer lists without help. For example, consider a simple aggregate:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span>, <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">B</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Agg</span> { A a; B b; };
</span></span><span style="display:flex;"><span><span style="color:#75715e">// No constructors defined – Agg is an aggregate
</span></span></span></code></pre></div><p>In C++17, if we attempt to create an <code>Agg</code> with braces, the compiler won’t deduce <code>&lt;A, B&gt;</code> by default. We must provide a deduction guide or the code will fail to compile. We can add one like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span>, <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">B</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>Agg(A, B) <span style="color:#f92672">-&gt;</span> Agg<span style="color:#f92672">&lt;</span>A, B<span style="color:#f92672">&gt;</span>;  <span style="color:#75715e">// guide to deduce Agg&lt;A,B&gt; from two constructor arguments
</span></span></span></code></pre></div><p>With this guide in place, <code>Agg agg{1, 2.0};</code> will deduce <code>A=int, B=double</code> resulting in an <code>Agg&lt;int, double&gt;</code>. (In C++20, the compiler becomes smarter – it can implicitly deduce aggregate class templates in many cases, eliminating the need for such guides. But in C++17, user-defined guides are typically required for aggregates.) Another use of custom guides is to handle conversions or non-trivial inference. For instance, one could write a non-templated guide <code>MyData(const char*) -&gt; MyData&lt;std::string&gt;;</code> so that <code>MyData md{&quot;hello&quot;}</code> deduces to <code>MyData&lt;std::string&gt;</code> instead of the default <code>MyData&lt;const char*&gt;</code>. This allows tailoring the deduction to more suitable types in specific situations.</p>
<p>The C++17 standard library itself provides many <strong>deduction guides</strong> for popular templates. The goal was to ensure that CTAD works intuitively for library types like containers, smart pointers, etc., even in tricky cases. For example, <code>std::vector</code> can deduce its <code>T</code> from an initializer_list or from iterator/value constructor arguments, <code>std::array</code> deduces both its element type and size, and <code>std::unique_ptr</code> uses guides to deduce the pointed type (distinguishing array pointers from single object pointers). All these guides are defined in the library headers so that you can use CTAD with standard types seamlessly. In general, <strong>non-aggregate class templates with at least one constructor don’t usually need manual guides</strong> – the constructors themselves drive deduction. It’s the cases of no constructors (pure aggregates) or wanting a different deduction than constructors provide that call for user-defined guides.</p>
<h2 id="examples-of-ctad-in-action">Examples of CTAD in Action</h2>
<p>Class template argument deduction greatly simplifies the syntax for creating objects of class templates. Here are several examples illustrating how it works in practice, compared to pre-C++17 code:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;utility&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;tuple&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;array&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;memory&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;type_traits&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// C++11/14 style – explicit template arguments or factory functions:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">double</span><span style="color:#f92672">&gt;</span> p1(<span style="color:#ae81ff">42</span>, <span style="color:#ae81ff">3.14</span>);        <span style="color:#75715e">// explicitly specify &lt;int,double&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">auto</span> p2 <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>make_pair(<span style="color:#ae81ff">42</span>, <span style="color:#ae81ff">3.14</span>);         <span style="color:#75715e">// use function template to deduce types
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// C++17 style – CTAD automatically deduces the template arguments:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>pair p3(<span style="color:#ae81ff">42</span>, <span style="color:#ae81ff">3.14</span>);                    <span style="color:#75715e">// deduces std::pair&lt;int, double&gt;:contentReference[oaicite:24]{index=24}
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>tuple t1(<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">15.5</span>, <span style="color:#e6db74">&#34;hello&#34;</span>);          <span style="color:#75715e">// deduces std::tuple&lt;int, double, const char*&gt;:contentReference[oaicite:25]{index=25}
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Deduction with container templates:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>vector v <span style="color:#f92672">=</span> {<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>};              <span style="color:#75715e">// deduces std::vector&lt;int&gt; (T=int from init-list)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>array arr <span style="color:#f92672">=</span> {std<span style="color:#f92672">::</span>string(<span style="color:#e6db74">&#34;A&#34;</span>), std<span style="color:#f92672">::</span>string(<span style="color:#e6db74">&#34;B&#34;</span>)}; 
</span></span><span style="display:flex;"><span>                                          <span style="color:#75715e">// deduces std::array&lt;std::string, 2&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// CTAD with smart pointers:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>unique_ptr ptr1(<span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>(<span style="color:#ae81ff">10</span>));        <span style="color:#75715e">// deduces std::unique_ptr&lt;int&gt;:contentReference[oaicite:26]{index=26}:contentReference[oaicite:27]{index=27}
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>unique_ptr ptr2(<span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>[<span style="color:#ae81ff">5</span>]);         <span style="color:#75715e">// deduces std::unique_ptr&lt;int[]&gt; (array version):contentReference[oaicite:28]{index=28}
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Custom class template example (aggregate):
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> X, <span style="color:#66d9ef">typename</span> Y<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Pair</span> { X first; Y second; };        <span style="color:#75715e">// aggregate, no constructors
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// (In C++17, need a guide for aggregate deduction)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> X, <span style="color:#66d9ef">typename</span> Y<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>Pair(X, Y) <span style="color:#f92672">-&gt;</span> Pair<span style="color:#f92672">&lt;</span>X, Y<span style="color:#f92672">&gt;</span>;                 <span style="color:#75715e">// guide: Pair(x,y) deduces Pair&lt;X,Y&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>Pair agg <span style="color:#f92672">=</span> {<span style="color:#ae81ff">123</span>, <span style="color:#ae81ff">7.89</span>};                   <span style="color:#75715e">// deduces Pair&lt;int, double&gt; from guide
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Verify some deduced types at compile time:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static_assert</span>(std<span style="color:#f92672">::</span>is_same_v<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">decltype</span>(p3), std<span style="color:#f92672">::</span>pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>,<span style="color:#66d9ef">double</span><span style="color:#f92672">&gt;&gt;</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static_assert</span>(std<span style="color:#f92672">::</span>is_same_v<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">decltype</span>(t1), std<span style="color:#f92672">::</span>tuple<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>,<span style="color:#66d9ef">double</span>,<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*&gt;&gt;</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static_assert</span>(std<span style="color:#f92672">::</span>is_same_v<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">decltype</span>(arr), std<span style="color:#f92672">::</span>array<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>string,<span style="color:#ae81ff">2</span><span style="color:#f92672">&gt;&gt;</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static_assert</span>(std<span style="color:#f92672">::</span>is_same_v<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">decltype</span>(ptr2), std<span style="color:#f92672">::</span>unique_ptr<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>[]<span style="color:#f92672">&gt;&gt;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;p3 = {&#34;</span> <span style="color:#f92672">&lt;&lt;</span> p3.first <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;, &#34;</span> <span style="color:#f92672">&lt;&lt;</span> p3.second <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;}</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span></code></pre></div><p>In the code above, <code>p3</code> is a <code>std::pair&lt;int,double&gt;</code> even though we wrote just <code>std::pair</code> – the compiler deduced the template arguments from the two constructor arguments (42 and 3.14). Likewise, <code>t1</code> becomes a <code>std::tuple&lt;int, double, const char*&gt;</code> by deducing each element type from the arguments given (notice that string literals yield <code>const char*</code> here). The commented static assertions illustrate the deduced types; these would pass at compile time, confirming the compiler’s decisions.</p>
<p>For the containers, <code>v</code> is deduced to <code>std::vector&lt;int&gt;</code> because we provided an initializer-list of <code>int</code>s. In C++14 you would have had to write <code>std::vector&lt;int&gt; v{…}</code> or rely on <code>auto</code>. With CTAD, the type <code>int</code> is inferred from the initializer list and the default allocator is applied for the second template parameter. Similarly, <code>arr</code> is deduced as <code>std::array&lt;std::string, 2&gt;</code> – here the deduction guide provided by the standard library uses the types of the two strings to determine that the array’s element type is <code>std::string</code> and the size is 2. Even mixed types can be handled: if we had <code>array arr2 = {1, 2u, 3u};</code>, the library’s guide uses <code>std::common_type_t</code> to deduce a common type (in this case <code>unsigned int</code>) and count 3 elements.</p>
<p>The <code>std::unique_ptr</code> examples demonstrate how CTAD works with smart pointers. <code>ptr1</code> is constructed from <code>new int(10)</code>, so the compiler deduces <code>T</code> as <code>int</code> and instantiates a <code>unique_ptr&lt;int&gt;</code> (the deleter uses the default). For <code>ptr2</code>, we pass <code>new int[5]</code> (an array of 5 ints). The standard library actually provides two deduction guides for <code>unique_ptr</code> – one for pointers to single objects and one for pointers to arrays. In this case, the pointer type looks like <code>int*</code> but the guide specifically maps it to <code>unique_ptr&lt;int[]&gt;</code> (array form) because <code>new int[5]</code> came from an array new-expression. As a result, <code>ptr2</code> is deduced to <code>std::unique_ptr&lt;int[]&gt;</code> without us specifying anything. This shows CTAD can even choose between overloads or specializations when guided appropriately by the library.</p>
<p>Finally, consider the custom <code>Pair</code> struct which is an aggregate (two public members, no constructors). In C++17, if we try to use <code>Pair agg = {123, 7.89};</code> without any help, the compiler wouldn’t deduce <code>&lt;int, double&gt;</code> on its own – CTAD for aggregates doesn’t kick in by default. We provided a user-defined deduction guide <code>Pair(X, Y) -&gt; Pair&lt;X,Y&gt;</code> to instruct the compiler that two constructor arguments of types X and Y should result in a <code>Pair&lt;X,Y&gt;</code>. With that guide in place, <code>agg</code> is successfully deduced as a <code>Pair&lt;int, double&gt;</code>. (This guide is essentially what the compiler <em>automatically</em> generates in C++20 for aggregates, but in C++17 we have to write it ourselves.)</p>
<h2 id="advantages-limitations-and-edge-cases-of-c17-ctad">Advantages, Limitations, and Edge Cases of C++17 CTAD</h2>
<p><strong>Benefits:</strong> The primary advantage of class template argument deduction is reduced verbosity and clearer code. By eliminating the need to redundantly specify template arguments that the compiler can infer, CTAD makes code more concise and expressive. This aligns with modern C++ style (e.g. using <code>auto</code> or template deduction elsewhere) to avoid repeating type information. It also avoids the need for many factory functions – you can construct objects of template classes directly and naturally. As noted earlier, reliance on helper templates like <code>make_pair</code> was <em>functional</em> but introduced extra layers of indirection and complexity. CTAD removes that burden: there’s no artificial function call, which can marginally improve compile times and make debugging easier (no stepping into <code>make_X</code> functions). In generic code, CTAD can improve template <em>composability</em>. For example, a function template can now return a class template object without the caller having to spell out the template arguments, making APIs more intuitive. Overall, C++17’s CTAD brings class templates closer to the ease-of-use of built-in types and function templates, increasing abstraction without cost.</p>
<p><strong>Limitations in C++17:</strong> Despite its usefulness, CTAD isn’t magic – it has some limitations and gotchas that developers should be aware of. One limitation is that <strong>partial deduction is not allowed</strong> – as mentioned, if you provide any template arguments explicitly, the compiler assumes you intend to specify all of them. For instance, <code>std::tuple&lt;int&gt; t(1, 2, 3);</code> is an error, because by specifying one template parameter, you turned off deduction for the others (and no matching constructor exists for <code>tuple&lt;int&gt;</code> with three arguments). The rule is all-or-none: either let CTAD deduce everything, or specify everything explicitly.</p>
<p>Another limitation in C++17 is with <strong>aggregate templates</strong>, which we’ve discussed. If a class template has no constructors (and is not a specialization with its own defaults), the compiler can’t deduce its parameters from an initializer list without a guide. This means in C++17 you may need to write user-defined deduction guides for your own aggregates to use them with CTAD. Failing to do so yields compiler errors for attempts at deduction. (C++20 fixes this by automatically generating guides for such cases, making the example <code>Agg{1,2.0}</code> work without manual intervention.)</p>
<p><strong>Potential ambiguity and complexity:</strong> In some scenarios, the presence of multiple constructors or deduction guides can lead to ambiguity or unexpected results. The compiler uses overload resolution to select the best deduction candidate. Usually the matching is straightforward (e.g. one constructor’s parameters fit the arguments best). But consider that CTAD also introduces an implicit <em>copy deduction</em> guide: a template that says <code>ClassName(ClassName&lt;T...&gt;) -&gt; ClassName&lt;T...&gt;</code> is always considered. This means that if you pass an object of the same template type into a class template’s constructor, the compiler prefers to deduce by “copying” that object’s exact template arguments rather than, say, using a more general templated constructor. In practice, this ensures that copy or move construction works as expected (you get the same specialization), but it can sometimes surprise developers if a templated constructor was meant to capture a broader range of types. The language rules resolve such conflicts by favoring the more specialized deduction candidate (often the implicit copy) over a user-defined guide or templated constructor.</p>
<p>Another edge case arises with <em>conversions</em>. CTAD will deduce types based on the constructor parameters and the arguments’ types or convertible types. If a conversion is needed to call a particular constructor, that constructor might not participate in deduction unless it’s a viable overload. For example, if you have a template constructor that takes a <code>T</code> and you pass an argument of a different type that can convert to <code>T</code>, the deduction will consider that conversion. In some cases, you might want to force a particular deduction – this is where a user-defined guide can override the default. The earlier example of mapping <code>const char*</code> to <code>std::string</code> is illustrative: normally, a template constructor <code>S(T)</code> would deduce <code>T</code> as <code>const char*</code> for a string literal, but by providing a guide, you can deduce it as <code>std::string</code> instead. Such guides have to be used judiciously to avoid conflicts, but they give library authors and users a way to fine-tune deduction.</p>
<p>One should also be mindful that CTAD infers template parameters purely from constructors and guides – it does <strong>not</strong> look at how the object is used later. This is usually intuitive, but in complex scenarios (especially involving templates within templates) you might encounter cases where the “obvious” deduction to a human isn’t done by the compiler because it has no contextual reason to do so. In those rare cases, you’d still need to specify template arguments or add a guide.</p>
<p>Finally, there’s a stylistic consideration: CTAD can make code <em>too</em> terse, to the point that the actual types become less obvious at a glance. Some codebases or developers might prefer explicit template arguments for clarity in public interfaces, or at least judicious use of CTAD. As with <code>auto</code>, the key is balance – CTAD is a tool that, when used appropriately, improves code, but it can be misused. That said, for most intermediate and advanced C++ developers, the benefits in reduced boilerplate outweigh the downside of having to sometimes infer the type mentally. Tools and IDEs nowadays can often show the deduced type to assist in readability.</p>
<h2 id="summary-and-future-considerations">Summary and Future Considerations</h2>
<p>C++17’s class template argument deduction is a powerful feature that makes templates more user-friendly and code more elegant. In this article, we saw how prior C++ standards required explicit template parameters for class templates and how C++17 changed the game by allowing the compiler to deduce those parameters from constructor arguments. We examined how deduction guides – implicit and user-defined – function as the mechanism enabling this deduction, and we walked through examples ranging from simple pairs and tuples to containers, smart pointers, and user-defined classes. CTAD bridges the gap between function templates and class templates, unifying the language’s ability to infer types and thus reducing verbosity and potential errors.</p>
<p>Looking beyond C++17, the evolution of template argument deduction has continued. C++20 built on C++17’s foundation by extending CTAD to <em>aggregates</em> automatically, so in many cases you no longer need to write explicit deduction guides for simple structs. C++20 also introduced <em>concepts</em> and <em>constraints</em>, which can be used in conjunction with CTAD to ensure that the deduced template arguments meet certain requirements (for example, you could constrain a deduction guide to only fire for particular types). These additions make template deduction more robust and expressive. As of C++23, no major new changes to CTAD have been introduced – the feature is now well-integrated into the language. Future standards may further refine template inference or address edge cases (the C++ committee has discussed interactions between CTAD and other features, and minor tweaks have been proposed to resolve quirks), but the core functionality is expected to remain as a reliable workhorse for C++ template programming.</p>
<p>In conclusion, template argument deduction for class templates is a welcome improvement from C++17 that simplifies template usage for programmers. It allows us to write code that is both <strong>safer</strong> (less chance of error by mismatched types) and <strong>cleaner</strong> (no redundant type specifications), exemplifying the modern C++ ethos of letting the compiler do the heavy lifting. By understanding its capabilities and limits, we can fully leverage CTAD to write more maintainable and expressive C++ code, all while citing the evidence of its effectiveness in both standard and user-defined templates.</p>

      </div>
    </article>

    <hr />

    <div class="post-info">
      
    <p>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7" y2="7"></line></svg>

        <span class="tag"><a href="https://blog.miguens.one/tags/c_cpp/">c_cpp</a></span>
        <span class="tag"><a href="https://blog.miguens.one/tags/programming/">programming</a></span>
        
    </p>

      
    <p>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-folder meta-icon"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path></svg>

        <span class="tag"><a href="https://blog.miguens.one/categories/technical/">technical</a></span>
        
    </p>


      <p>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text">
          <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
          <polyline points="14 2 14 8 20 8"></polyline>
          <line x1="16" y1="13" x2="8" y2="13"></line>
          <line x1="16" y1="17" x2="8" y2="17"></line>
          <polyline points="10 9 9 9 8 9"></polyline>
        </svg>
        2972 Words
      </p>

      <p>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar">
          <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
          <line x1="16" y1="2" x2="16" y2="6"></line>
          <line x1="8" y1="2" x2="8" y2="6"></line>
          <line x1="3" y1="10" x2="21" y2="10"></line>
        </svg>
        
          2025-06-26
        

         
          
        
      </p>
    </div>
      <hr />
      <div class="sharing-buttons">
        
<a class="resp-sharing-button__link" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fblog.miguens.one%2fposts%2f2025%2f06%2ftemplate-argument-deduction-for-class-templates-in-c-17%2f" target="_blank" rel="noopener" aria-label="" title="Share on facebook">
  <div class="resp-sharing-button resp-sharing-button--facebook resp-sharing-button--small"><div aria-hidden="true" class="resp-sharing-button__icon resp-sharing-button__icon--solid">
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 2h-3a5 5 0 0 0-5 5v3H7v4h3v8h4v-8h3l1-4h-4V7a1 1 0 0 1 1-1h3z"></path></svg>
    </div>
  </div>
</a>


<a class="resp-sharing-button__link" href="https://twitter.com/intent/tweet/?url=https%3a%2f%2fblog.miguens.one%2fposts%2f2025%2f06%2ftemplate-argument-deduction-for-class-templates-in-c-17%2f" target="_blank" rel="noopener" aria-label="" title="Share on twitter">
  <div class="resp-sharing-button resp-sharing-button--twitter resp-sharing-button--small">
      <div aria-hidden="true" class="resp-sharing-button__icon resp-sharing-button__icon--solid">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"></path></svg>
    </div>
  </div>
</a>


<a class="resp-sharing-button__link" href="https://www.tumblr.com/widgets/share/tool?posttype=link&amp;title=Template%20Argument%20Deduction%20for%20Class%20Templates%20in%20C%2b%2b17&amp;caption=Template%20Argument%20Deduction%20for%20Class%20Templates%20in%20C%2b%2b17&amp;canonicalUrl=https%3a%2f%2fblog.miguens.one%2fposts%2f2025%2f06%2ftemplate-argument-deduction-for-class-templates-in-c-17%2f" target="_blank" rel="noopener" aria-label="" title="Share on tumblr">
  <div class="resp-sharing-button resp-sharing-button--tumblr resp-sharing-button--small">
    <div aria-hidden="true" class="resp-sharing-button__icon resp-sharing-button__icon--solid">
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor" stroke="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14.563 24c-5.093 0-7.031-3.756-7.031-6.411V9.747H5.116V6.648c3.63-1.313 4.512-4.596 4.71-6.469C9.84.051 9.941 0 9.999 0h3.517v6.114h4.801v3.633h-4.82v7.47c.016 1.001.375 2.371 2.207 2.371h.09c.631-.02 1.486-.205 1.936-.419l1.156 3.425c-.436.636-2.4 1.374-4.156 1.404h-.178l.011.002z"/></svg>
    </div>
  </div>
</a>


<a class="resp-sharing-button__link" href="mailto:?subject=Template%20Argument%20Deduction%20for%20Class%20Templates%20in%20C%2b%2b17&amp;body=https%3a%2f%2fblog.miguens.one%2fposts%2f2025%2f06%2ftemplate-argument-deduction-for-class-templates-in-c-17%2f" target="_self" rel="noopener" aria-label="" title="Share via email">
  <div class="resp-sharing-button resp-sharing-button--email resp-sharing-button--small"><div aria-hidden="true" class="resp-sharing-button__icon resp-sharing-button__icon--solid">
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path><polyline points="22,6 12,13 2,6"></polyline></svg>
    </div>
  </div>
</a>


<a class="resp-sharing-button__link" href="https://pinterest.com/pin/create/button/?url=https%3a%2f%2fblog.miguens.one%2fposts%2f2025%2f06%2ftemplate-argument-deduction-for-class-templates-in-c-17%2f&amp;media=https%3a%2f%2fblog.miguens.one%2fposts%2f2025%2f06%2ftemplate-argument-deduction-for-class-templates-in-c-17%2f;description=Template%20Argument%20Deduction%20for%20Class%20Templates%20in%20C%2b%2b17" target="_blank" rel="noopener" aria-label="" title="Share on pinterest">
  <div class="resp-sharing-button resp-sharing-button--pinterest resp-sharing-button--small"><div aria-hidden="true" class="resp-sharing-button__icon resp-sharing-button__icon--solid">
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor" stroke="none"><path d="M12.017 0C5.396 0 .029 5.367.029 11.987c0 5.079 3.158 9.417 7.618 11.162-.105-.949-.199-2.403.041-3.439.219-.937 1.406-5.957 1.406-5.957s-.359-.72-.359-1.781c0-1.663.967-2.911 2.168-2.911 1.024 0 1.518.769 1.518 1.688 0 1.029-.653 2.567-.992 3.992-.285 1.193.6 2.165 1.775 2.165 2.128 0 3.768-2.245 3.768-5.487 0-2.861-2.063-4.869-5.008-4.869-3.41 0-5.409 2.562-5.409 5.199 0 1.033.394 2.143.889 2.741.099.12.112.225.085.345-.09.375-.293 1.199-.334 1.363-.053.225-.172.271-.401.165-1.495-.69-2.433-2.878-2.433-4.646 0-3.776 2.748-7.252 7.92-7.252 4.158 0 7.392 2.967 7.392 6.923 0 4.135-2.607 7.462-6.233 7.462-1.214 0-2.354-.629-2.758-1.379l-.749 2.848c-.269 1.045-1.004 2.352-1.498 3.146 1.123.345 2.306.535 3.55.535 6.607 0 11.985-5.365 11.985-11.987C23.97 5.39 18.592.026 11.985.026L12.017 0z"/></svg>
    </div>
  </div>
</a>


<a class="resp-sharing-button__link" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fblog.miguens.one%2fposts%2f2025%2f06%2ftemplate-argument-deduction-for-class-templates-in-c-17%2f&amp;title=Template%20Argument%20Deduction%20for%20Class%20Templates%20in%20C%2b%2b17&amp;summary=Template%20Argument%20Deduction%20for%20Class%20Templates%20in%20C%2b%2b17&amp;source=https%3a%2f%2fblog.miguens.one%2fposts%2f2025%2f06%2ftemplate-argument-deduction-for-class-templates-in-c-17%2f" target="_blank" rel="noopener" aria-label="" title="Share on linkedin">
  <div class="resp-sharing-button resp-sharing-button--linkedin resp-sharing-button--small"><div aria-hidden="true" class="resp-sharing-button__icon resp-sharing-button__icon--solid">
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2 2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6z"></path><rect x="2" y="9" width="4" height="12"></rect><circle cx="4" cy="4" r="2"></circle></svg>
    </div>
  </div>
</a>


<a class="resp-sharing-button__link" href="https://reddit.com/submit/?url=https%3a%2f%2fblog.miguens.one%2fposts%2f2025%2f06%2ftemplate-argument-deduction-for-class-templates-in-c-17%2f&amp;resubmit=true&amp;title=Template%20Argument%20Deduction%20for%20Class%20Templates%20in%20C%2b%2b17" target="_blank" rel="noopener" aria-label="" title="Share on reddit">
  <div class="resp-sharing-button resp-sharing-button--reddit resp-sharing-button--small"><div aria-hidden="true" class="resp-sharing-button__icon resp-sharing-button__icon--solid">
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor" stroke="none"><path d="M12 0A12 12 0 0 0 0 12a12 12 0 0 0 12 12 12 12 0 0 0 12-12A12 12 0 0 0 12 0zm5.01 4.744c.688 0 1.25.561 1.25 1.249a1.25 1.25 0 0 1-2.498.056l-2.597-.547-.8 3.747c1.824.07 3.48.632 4.674 1.488.308-.309.73-.491 1.207-.491.968 0 1.754.786 1.754 1.754 0 .716-.435 1.333-1.01 1.614a3.111 3.111 0 0 1 .042.52c0 2.694-3.13 4.87-7.004 4.87-3.874 0-7.004-2.176-7.004-4.87 0-.183.015-.366.043-.534A1.748 1.748 0 0 1 4.028 12c0-.968.786-1.754 1.754-1.754.463 0 .898.196 1.207.49 1.207-.883 2.878-1.43 4.744-1.487l.885-4.182a.342.342 0 0 1 .14-.197.35.35 0 0 1 .238-.042l2.906.617a1.214 1.214 0 0 1 1.108-.701zM9.25 12C8.561 12 8 12.562 8 13.25c0 .687.561 1.248 1.25 1.248.687 0 1.248-.561 1.248-1.249 0-.688-.561-1.249-1.249-1.249zm5.5 0c-.687 0-1.248.561-1.248 1.25 0 .687.561 1.248 1.249 1.248.688 0 1.249-.561 1.249-1.249 0-.687-.562-1.249-1.25-1.249zm-5.466 3.99a.327.327 0 0 0-.231.094.33.33 0 0 0 0 .463c.842.842 2.484.913 2.961.913.477 0 2.105-.056 2.961-.913a.361.361 0 0 0 .029-.463.33.33 0 0 0-.464 0c-.547.533-1.684.73-2.512.73-.828 0-1.979-.196-2.512-.73a.326.326 0 0 0-.232-.095z"/></svg>
    </div>
  </div>
</a>


<a class="resp-sharing-button__link" href="https://www.xing.com/app/user?op=share;url=https%3a%2f%2fblog.miguens.one%2fposts%2f2025%2f06%2ftemplate-argument-deduction-for-class-templates-in-c-17%2f;title=Template%20Argument%20Deduction%20for%20Class%20Templates%20in%20C%2b%2b17" target="_blank" rel="noopener" aria-label="" title="Share on xing">
  <div class="resp-sharing-button resp-sharing-button--xing resp-sharing-button--small"><div aria-hidden="true" class="resp-sharing-button__icon resp-sharing-button__icon--solid">
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor" stroke="none"><path d="M18.188 0c-.517 0-.741.325-.927.66 0 0-7.455 13.224-7.702 13.657.015.024 4.919 9.023 4.919 9.023.17.308.436.66.967.66h3.454c.211 0 .375-.078.463-.22.089-.151.089-.346-.009-.536l-4.879-8.916c-.004-.006-.004-.016 0-.022L22.139.756c.095-.191.097-.387.006-.535C22.056.078 21.894 0 21.686 0h-3.498zM3.648 4.74c-.211 0-.385.074-.473.216-.09.149-.078.339.02.531l2.34 4.05c.004.01.004.016 0 .021L1.86 16.051c-.099.188-.093.381 0 .529.085.142.239.234.45.234h3.461c.518 0 .766-.348.945-.667l3.734-6.609-2.378-4.155c-.172-.315-.434-.659-.962-.659H3.648v.016z"/></svg>
    </div>
  </div>
</a>


<a class="resp-sharing-button__link" href="whatsapp://send?text=Template%20Argument%20Deduction%20for%20Class%20Templates%20in%20C%2b%2b17%20https%3a%2f%2fblog.miguens.one%2fposts%2f2025%2f06%2ftemplate-argument-deduction-for-class-templates-in-c-17%2f" target="_blank" rel="noopener" aria-label="" title="Share on whatsapp">
  <div class="resp-sharing-button resp-sharing-button--whatsapp resp-sharing-button--small"><div aria-hidden="true" class="resp-sharing-button__icon resp-sharing-button__icon--solid">
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor" stroke="none" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"><path d="M17.472 14.382c-.297-.149-1.758-.867-2.03-.967-.273-.099-.471-.148-.67.15-.197.297-.767.966-.94 1.164-.173.199-.347.223-.644.075-.297-.15-1.255-.463-2.39-1.475-.883-.788-1.48-1.761-1.653-2.059-.173-.297-.018-.458.13-.606.134-.133.298-.347.446-.52.149-.174.198-.298.298-.497.099-.198.05-.371-.025-.52-.075-.149-.669-1.612-.916-2.207-.242-.579-.487-.5-.669-.51-.173-.008-.371-.01-.57-.01-.198 0-.52.074-.792.372-.272.297-1.04 1.016-1.04 2.479 0 1.462 1.065 2.875 1.213 3.074.149.198 2.096 3.2 5.077 4.487.709.306 1.262.489 1.694.625.712.227 1.36.195 1.871.118.571-.085 1.758-.719 2.006-1.413.248-.694.248-1.289.173-1.413-.074-.124-.272-.198-.57-.347m-5.421 7.403h-.004a9.87 9.87 0 01-5.031-1.378l-.361-.214-3.741.982.998-3.648-.235-.374a9.86 9.86 0 01-1.51-5.26c.001-5.45 4.436-9.884 9.888-9.884 2.64 0 5.122 1.03 6.988 2.898a9.825 9.825 0 012.893 6.994c-.003 5.45-4.437 9.884-9.885 9.884m8.413-18.297A11.815 11.815 0 0012.05 0C5.495 0 .16 5.335.157 11.892c0 2.096.547 4.142 1.588 5.945L.057 24l6.305-1.654a11.882 11.882 0 005.683 1.448h.005c6.554 0 11.89-5.335 11.893-11.893a11.821 11.821 0 00-3.48-8.413Z"/></svg>
    </div>
  </div>
</a>


<a class="resp-sharing-button__link" href="https://news.ycombinator.com/submitlink?u=https%3a%2f%2fblog.miguens.one%2fposts%2f2025%2f06%2ftemplate-argument-deduction-for-class-templates-in-c-17%2f&amp;t=Template%20Argument%20Deduction%20for%20Class%20Templates%20in%20C%2b%2b17" target="_blank" rel="noopener" aria-label="" title="Share on hacker news">
  <div class="resp-sharing-button resp-sharing-button--hackernews resp-sharing-button--small"><div aria-hidden="true" class="resp-sharing-button__icon resp-sharing-button__icon--solid">
			<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor" stroke="none"><path d="M0 24V0h24v24H0zM6.951 5.896l4.112 7.708v5.064h1.583v-4.972l4.148-7.799h-1.749l-2.457 4.875c-.372.745-.688 1.434-.688 1.434s-.297-.708-.651-1.434L8.831 5.896h-1.88z"/></svg>
    </div>
  </div>
</a>


<a class="resp-sharing-button__link" href="https://telegram.me/share/url?text=Template%20Argument%20Deduction%20for%20Class%20Templates%20in%20C%2b%2b17&amp;url=https%3a%2f%2fblog.miguens.one%2fposts%2f2025%2f06%2ftemplate-argument-deduction-for-class-templates-in-c-17%2f" target="_blank" rel="noopener" aria-label="" title="Share on telegram">
  <div class="resp-sharing-button resp-sharing-button--telegram resp-sharing-button--small"><div aria-hidden="true" class="resp-sharing-button__icon resp-sharing-button__icon--solid">
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="22" y1="2" x2="11" y2="13"></line><polygon points="22 2 15 22 11 13 2 9 22 2"></polygon></svg>
    </div>
  </div>
</a>

      </div>

    
    <div class="pagination">
        

        <div class="pagination__buttons">
            
            <span class="button previous">
                <a href="https://blog.miguens.one/posts/2025/06/the-filesystem-library-in-c-17-a-comprehensive-introduction/">
                    <span class="button__icon">←</span>
                    <span class="button__text">The Filesystem Library in C&#43;&#43;17: A Comprehensive Introduction</span>
                </a>
            </span>
            

            
            <span class="button next">
                <a href="https://blog.miguens.one/posts/2025/06/inline-variables-in-c-17-odr-safe-header-definitions/">
                    <span class="button__text">Inline Variables in C&#43;&#43;17: ODR-Safe Header Definitions</span>
                    <span class="button__icon">→</span>
                </a>
            </span>
            
        </div>
    </div>


    

    

    

  </main>

            </div>

            
                <footer class="footer">
    
    
</footer>

            
        </div>

        



<script type="text/javascript" src="https://blog.miguens.one/bundle.min.ad54ad97364f77ede35def9096b162bb1f0b3973aa50b080f5e82fa147f6882e2a7200d7535adbf9b51bebf939f1c1ca9bbe6be87530092aca720eac4a226fda.js" integrity="sha512-rVStlzZPd&#43;3jXe&#43;QlrFiux8LOXOqULCA9egvoUf2iC4qcgDXU1rb&#43;bUb6/k58cHKm75r6HUwCSrKcg6sSiJv2g=="></script>




    </body>
</html>
