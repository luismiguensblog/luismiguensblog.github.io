<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="author" content="">
<meta name="description" content="Introduction Memory management in C&#43;&#43; has traditionally required careful use of dynamic allocation and manual deallocation. Mistakes in managing memory (such as forgetting to delete allocated memory or deleting it twice) can lead to resource leaks, dangling pointers, or crashes. Modern C&#43;&#43; addresses these issues with RAII (Resource Acquisition Is Initialisation) and smart pointers, which automatically manage the lifetime of dynamically allocated objects and help prevent resource leaks (R: Resource management – C&#43;&#43;). This article provides an in-depth look at C&#43;&#43;17 smart pointers – std::unique_ptr, std::shared_ptr, and std::weak_ptr – explaining their functionalities, benefits, and best use cases. We will also discuss best practices for dynamic memory allocation, including ownership semantics, avoiding leaks, and performance considerations. The discussion assumes you are an intermediate or advanced C&#43;&#43; developer familiar with basic pointers and memory concepts.
" />
<meta name="keywords" content=", c_cpp, programming" />
<meta name="robots" content="noodp" />
<meta name="theme-color" content="" />
<link rel="canonical" href="https://blog.miguens.one/posts/2025/03/smart-pointers-and-memory-management-in-c-17/" />


    <title>
        
            Smart Pointers and Memory Management in C&#43;&#43;17 :: Luis Miguens Blog 
        
    </title>





  <link rel="stylesheet" href="https://blog.miguens.one/main.min.2729760c629597024c5de34b40ea9f372f2b5a2a192dcdca537b7ddfa483eab8.css" integrity="sha256-Jyl2DGKVlwJMXeNLQOqfNy8rWioZLc3KU3t936SD6rg=" crossorigin="anonymous">





    <link rel="apple-touch-icon" sizes="180x180" href="https://blog.miguens.one/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="https://blog.miguens.one/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="https://blog.miguens.one/favicon-16x16.png">
    <link rel="manifest" href="https://blog.miguens.one/site.webmanifest">
    <link rel="mask-icon" href="https://blog.miguens.one/safari-pinned-tab.svg" color="">
    <link rel="shortcut icon" href="https://blog.miguens.one/favicon.ico">
    <meta name="msapplication-TileColor" content="">



  <meta itemprop="name" content="Smart Pointers and Memory Management in C&#43;&#43;17">
  <meta itemprop="description" content="Introduction Memory management in C&#43;&#43; has traditionally required careful use of dynamic allocation and manual deallocation. Mistakes in managing memory (such as forgetting to delete allocated memory or deleting it twice) can lead to resource leaks, dangling pointers, or crashes. Modern C&#43;&#43; addresses these issues with RAII (Resource Acquisition Is Initialisation) and smart pointers, which automatically manage the lifetime of dynamically allocated objects and help prevent resource leaks (R: Resource management – C&#43;&#43;). This article provides an in-depth look at C&#43;&#43;17 smart pointers – std::unique_ptr, std::shared_ptr, and std::weak_ptr – explaining their functionalities, benefits, and best use cases. We will also discuss best practices for dynamic memory allocation, including ownership semantics, avoiding leaks, and performance considerations. The discussion assumes you are an intermediate or advanced C&#43;&#43; developer familiar with basic pointers and memory concepts.">
  <meta itemprop="datePublished" content="2025-03-07T00:00:00+00:00">
  <meta itemprop="dateModified" content="2025-03-07T00:00:00+00:00">
  <meta itemprop="wordCount" content="4207">
  <meta itemprop="image" content="https://blog.miguens.one/">
  <meta itemprop="keywords" content="C_cpp,Programming">

  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:image" content="https://blog.miguens.one/">
  <meta name="twitter:title" content="Smart Pointers and Memory Management in C&#43;&#43;17">
  <meta name="twitter:description" content="Introduction Memory management in C&#43;&#43; has traditionally required careful use of dynamic allocation and manual deallocation. Mistakes in managing memory (such as forgetting to delete allocated memory or deleting it twice) can lead to resource leaks, dangling pointers, or crashes. Modern C&#43;&#43; addresses these issues with RAII (Resource Acquisition Is Initialisation) and smart pointers, which automatically manage the lifetime of dynamically allocated objects and help prevent resource leaks (R: Resource management – C&#43;&#43;). This article provides an in-depth look at C&#43;&#43;17 smart pointers – std::unique_ptr, std::shared_ptr, and std::weak_ptr – explaining their functionalities, benefits, and best use cases. We will also discuss best practices for dynamic memory allocation, including ownership semantics, avoiding leaks, and performance considerations. The discussion assumes you are an intermediate or advanced C&#43;&#43; developer familiar with basic pointers and memory concepts.">



    <meta property="og:url" content="https://blog.miguens.one/posts/2025/03/smart-pointers-and-memory-management-in-c-17/">
  <meta property="og:site_name" content="Luis Miguens Blog">
  <meta property="og:title" content="Smart Pointers and Memory Management in C&#43;&#43;17">
  <meta property="og:description" content="Introduction Memory management in C&#43;&#43; has traditionally required careful use of dynamic allocation and manual deallocation. Mistakes in managing memory (such as forgetting to delete allocated memory or deleting it twice) can lead to resource leaks, dangling pointers, or crashes. Modern C&#43;&#43; addresses these issues with RAII (Resource Acquisition Is Initialisation) and smart pointers, which automatically manage the lifetime of dynamically allocated objects and help prevent resource leaks (R: Resource management – C&#43;&#43;). This article provides an in-depth look at C&#43;&#43;17 smart pointers – std::unique_ptr, std::shared_ptr, and std::weak_ptr – explaining their functionalities, benefits, and best use cases. We will also discuss best practices for dynamic memory allocation, including ownership semantics, avoiding leaks, and performance considerations. The discussion assumes you are an intermediate or advanced C&#43;&#43; developer familiar with basic pointers and memory concepts.">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-03-07T00:00:00+00:00">
    <meta property="article:modified_time" content="2025-03-07T00:00:00+00:00">
    <meta property="article:tag" content="C_cpp">
    <meta property="article:tag" content="Programming">
    <meta property="og:image" content="https://blog.miguens.one/">




    <meta property="article:section" content="technical" />



    <meta property="article:published_time" content="2025-03-07 00:00:00 &#43;0000 UTC" />









    
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-ZHDRD7M8H9"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-ZHDRD7M8H9');
        }
      </script>



    </head>

    
        <body>
    
    
        <div class="container">
            <header class="header">
    <span class="header__inner">
        <a href="https://blog.miguens.one/" style="text-decoration: none;">
    <div class="logo">
        
            <span class="logo__mark">&gt;</span>
            <span class="logo__text ">
                $ cd /home/</span>
            <span class="logo__cursor" style=
                  "
                   
                   ">
            </span>
        
    </div>
</a>


        <span class="header__right">
                <nav class="menu">
    <ul class="menu__inner"><li><a href="https://blog.miguens.one/about/">About</a></li><li><a href="https://blog.miguens.one/categories/">Categories</a></li><li><a href="https://blog.miguens.one/posts/">Posts</a></li>
    </ul>
</nav>

                <span class="menu-trigger">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                        <path d="M0 0h24v24H0z" fill="none"/>
                        <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
                    </svg>
                </span>
        </span>
    </span>
</header>


            <div class="content">
                
  <main class="post">

    <div class="post-info">
      <p>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock">
          <circle cx="12" cy="12" r="10"></circle>
          <polyline points="12 6 12 12 16 14"></polyline>
        </svg>
        20 minutes

        
      </p>
    </div>

    <article>
      <h1 class="post-title">
        <a href="https://blog.miguens.one/posts/2025/03/smart-pointers-and-memory-management-in-c-17/">Smart Pointers and Memory Management in C++17</a>
      </h1>

      

      

      

      <div class="post-content">
        <h2 id="introduction">Introduction</h2>
<p>Memory management in C++ has traditionally required careful use of dynamic allocation and manual deallocation. Mistakes in managing memory (such as forgetting to delete allocated memory or deleting it twice) can lead to resource leaks, dangling pointers, or crashes. Modern C++ addresses these issues with <strong>RAII</strong> (Resource Acquisition Is Initialisation) and <strong>smart pointers</strong>, which automatically manage the lifetime of dynamically allocated objects and help prevent resource leaks (<a href="https://cpp-core-guidelines-docs.vercel.app/resource#:~:text=They%20can%20prevent%20resource%20leaks">R: Resource management – C++</a>). This article provides an in-depth look at C++17 smart pointers – <code>std::unique_ptr</code>, <code>std::shared_ptr</code>, and <code>std::weak_ptr</code> – explaining their functionalities, benefits, and best use cases. We will also discuss best practices for dynamic memory allocation, including ownership semantics, avoiding leaks, and performance considerations. The discussion assumes you are an intermediate or advanced C++ developer familiar with basic pointers and memory concepts.</p>
<h2 id="stdunique_ptr--exclusive-ownership"><code>std::unique_ptr</code> – Exclusive Ownership</h2>
<p><code>std::unique_ptr</code> is a smart pointer that retains <strong>sole (unique) ownership</strong> of a dynamically allocated object (<a href="https://my.eng.utah.edu/~pajensen/ACM/Documentation/c-reference/en.cppreference.com/w/cpp/memory/unique_ptrhtml.html#:~:text=,that">std::unique_ptr - cppreference.com</a>). Only one <code>unique_ptr</code> at a time can own a given object; when the <code>unique_ptr</code> is destroyed or reset, it automatically deletes the managed object. This exclusive ownership model ensures that there is no ambiguity about who is responsible for freeing the memory – the <code>unique_ptr</code> will do it when it goes out of scope. In other words, <code>unique_ptr</code> implements strict RAII for single-owner resources, meaning the resource is acquired and released in tandem with the <code>unique_ptr</code>&rsquo;s lifetime. It replaces the now-deprecated <code>auto_ptr</code> (removed in C++17) and is the <strong>default smart pointer to use for owning dynamically allocated objects</strong> when shared ownership is not needed (<a href="https://learn.microsoft.com/en-us/cpp/cpp/smart-pointers-modern-cpp?view=msvc-170#:~:text=,and%20Use%20unique_ptr%20Instances%20and">Smart pointers (Modern C++) | Microsoft Learn</a>).</p>
<p>A <code>unique_ptr</code> cannot be copied (copy construction/assignment is deleted) to avoid multiple owners, but it <em>can be moved</em>. This allows transferring ownership from one <code>unique_ptr</code> to another (for example, when returning a dynamically allocated object from a function). <code>unique_ptr</code> is lightweight: it typically consists of just a single pointer internally, so its size and performance are comparable to raw pointers (<a href="https://learn.microsoft.com/en-us/cpp/cpp/smart-pointers-modern-cpp?view=msvc-170#:~:text=,and%20Use%20unique_ptr%20Instances%20and">Smart pointers (Modern C++) | Microsoft Learn</a>). There is negligible overhead in using a <code>unique_ptr</code> compared to a raw pointer, and accessing the managed object (via <code>operator*</code> or <code>operator-&gt;</code>) is as fast as dereferencing a raw pointer. The only extra work happens on destruction, where it deletes the object, which is exactly what manual <code>delete</code> would do.</p>
<p><strong>Usage example:</strong> Creating and using a <code>std::unique_ptr</code>. In this example, we allocate an <code>int</code> and a custom <code>MyObject</code> using <code>std::make_unique</code> (introduced in C++14) which is the recommended way to create <code>unique_ptr</code>s. We also demonstrate transferring ownership with <code>std::move</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;memory&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">MyObject</span> {
</span></span><span style="display:flex;"><span>    MyObject(<span style="color:#66d9ef">int</span> x) <span style="color:#f92672">:</span> data(x) { std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;MyObject constructed</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>; }
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">~</span>MyObject() { std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;MyObject destroyed</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>; }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> data;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>unique_ptr<span style="color:#f92672">&lt;</span>MyObject<span style="color:#f92672">&gt;</span> createObject(<span style="color:#66d9ef">int</span> value) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> std<span style="color:#f92672">::</span>make_unique<span style="color:#f92672">&lt;</span>MyObject<span style="color:#f92672">&gt;</span>(value);  <span style="color:#75715e">// allocate and return a unique_ptr
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>unique_ptr<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> ptr1 <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>make_unique<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(<span style="color:#ae81ff">42</span>);       <span style="color:#75715e">// unique_ptr owning an int
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>unique_ptr<span style="color:#f92672">&lt;</span>MyObject<span style="color:#f92672">&gt;</span> objPtr <span style="color:#f92672">=</span> createObject(<span style="color:#ae81ff">10</span>);         <span style="color:#75715e">// unique_ptr owning MyObject(10)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// std::unique_ptr&lt;MyObject&gt; objPtr2 = objPtr; // Error: cannot copy unique_ptr
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>unique_ptr<span style="color:#f92672">&lt;</span>MyObject<span style="color:#f92672">&gt;</span> objPtr2 <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>move(objPtr);       <span style="color:#75715e">// Transfer ownership to objPtr2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;objPtr2-&gt;data = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> objPtr2<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;    <span style="color:#75715e">// use the object
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// objPtr is now null (ownership moved), objPtr2 owns the MyObject
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    objPtr2.reset();  <span style="color:#75715e">// manually delete the object early (optional)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// The MyObject is destroyed here, before objPtr2 goes out of scope.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}  <span style="color:#75715e">// ptr1 goes out of scope and deletes the int automatically here
</span></span></span></code></pre></div><p>In this snippet, <code>ptr1</code> and <code>objPtr</code> are <code>unique_ptr</code>s that own their respective objects. We move <code>objPtr</code> to <code>objPtr2</code>, illustrating how ownership is transferred. When <code>objPtr2.reset()</code> is called or when <code>ptr1</code>/<code>objPtr2</code> go out of scope, the owned objects are deleted automatically. There is no need to call <code>delete</code> explicitly, and hence no risk of forgetting to delete (preventing memory leaks) or deleting twice. The exclusive ownership model makes <code>std::unique_ptr</code> ideal for cases where a resource is used by only one object or function at a time, such as managing dynamically allocated memory within a single scope or owning resource handles in a class. It provides clear ownership semantics and very low overhead (<a href="https://learn.microsoft.com/en-us/cpp/cpp/smart-pointers-modern-cpp?view=msvc-170#:~:text=,and%20Use%20unique_ptr%20Instances%20and">Smart pointers (Modern C++) | Microsoft Learn</a>).</p>
<p><strong>Benefits and best use cases:</strong> Use <code>std::unique_ptr</code> as the <strong>default choice</strong> for managing dynamically allocated objects that do not need to be shared (<a href="https://learn.microsoft.com/en-us/cpp/cpp/smart-pointers-modern-cpp?view=msvc-170#:~:text=,and%20Use%20unique_ptr%20Instances%20and">Smart pointers (Modern C++) | Microsoft Learn</a>). Its benefits include automatic deletion (preventing leaks) and no performance penalty for reference counting. For example, you would use <code>unique_ptr</code> for a tree or list node owned by one data structure, for managing a resource in a RAII wrapper class, or for any factory function that creates an object and transfers ownership to the caller. Because it cannot be copied, <code>unique_ptr</code> makes ownership transfer explicit and avoids accidental aliasing. If you need to share ownership or have multiple references to the same object, then <code>unique_ptr</code> alone is insufficient – that is where <code>std::shared_ptr</code> comes in, but you should prefer <code>unique_ptr</code> whenever exclusive ownership is appropriate (<a href="https://cpp-core-guidelines-docs.vercel.app/resource#:~:text=">R: Resource management – C++</a>). In summary, <code>unique_ptr</code> provides exception-safe, clear ownership with minimal runtime cost, solving the problem of remembering to free memory by tying the memory’s lifetime to an object’s scope.</p>
<h2 id="stdshared_ptr--shared-ownership-via-reference-counting"><code>std::shared_ptr</code> – Shared Ownership via Reference Counting</h2>
<p><code>std::shared_ptr</code> is a smart pointer that retains <strong>shared ownership</strong> of an object through a pointer (<a href="https://en.cppreference.com/w/cpp/memory/shared_ptr#:~:text=,either%20of%20the%20following%20happens">std::shared_ptr - cppreference.com</a>). This means multiple <code>shared_ptr</code> instances can point to the same object, and the object will remain alive as long as at least one <code>shared_ptr</code> owns it. Internally, <code>shared_ptr</code> uses a reference counting mechanism: it maintains a <em>use count</em> (in a separate control block) of how many <code>shared_ptr</code>s refer to the object. When you copy a <code>shared_ptr</code>, the reference count is incremented; when a <code>shared_ptr</code> is destroyed or reset, the count is decremented. When the count drops to zero (i.e., no more owners), the managed object is deleted and its memory is freed (<a href="https://learn.microsoft.com/en-us/cpp/cpp/smart-pointers-modern-cpp?view=msvc-170#:~:text=%2A%20%60shared_ptr%60%20Reference,memory%3E%60.%20For">Smart pointers (Modern C++) | Microsoft Learn</a>). This automatic deletion on zero count makes <code>shared_ptr</code> a powerful tool for managing objects that need to be accessed from multiple places without a clear single owner.</p>
<p>A <code>shared_ptr</code> can be default-constructed or set to <code>nullptr</code> to represent an empty pointer. Like <code>unique_ptr</code>, it supports <code>operator-&gt;</code> and <code>operator*</code> to access the underlying object. Unlike <code>unique_ptr</code>, <code>shared_ptr</code> is copyable (the copy shares ownership), which means you <strong>must be careful</strong> that sharing is actually what you want. If you copy a <code>shared_ptr</code> inadvertently, you may be extending an object’s lifetime longer than intended. As a rule of thumb, prefer passing a <code>shared_ptr</code> by reference or const reference to functions if you don’t need to increase the reference count, to avoid unnecessary copies.</p>
<p><strong>Memory and performance considerations:</strong> Because of the reference count, a <code>shared_ptr</code> is larger and slightly slower than a raw pointer or <code>unique_ptr</code>. Typically, a <code>shared_ptr</code> contains two pointers internally – one to the managed object and one to the control block holding the reference count and deleter (<a href="https://learn.microsoft.com/en-us/cpp/cpp/smart-pointers-modern-cpp?view=msvc-170#:~:text=container%20but%20want%20to%20keep,memory%3E%60.%20For">Smart pointers (Modern C++) | Microsoft Learn</a>). Managing the reference count involves atomic operations (to allow thread-safe updates to the count), which incur a performance cost. In single-threaded scenarios the overhead is minimal, but in multithreaded scenarios each copy or destruction of a <code>shared_ptr</code> triggers an atomic ref-count update. If you do not actually need shared ownership, this overhead is wasted – which is why the C++ Core Guidelines advise preferring <code>unique_ptr</code> over <code>shared_ptr</code> unless sharing is required, as <code>unique_ptr</code> is faster and more predictable (no atomic count updates) (<a href="https://cpp-core-guidelines-docs.vercel.app/resource#:~:text=">R: Resource management – C++</a>). That said, <code>shared_ptr</code> is designed for convenience and safety; the small performance cost is usually acceptable when you truly need multiple owners. Furthermore, creating a <code>shared_ptr</code> with <code>std::make_shared</code> can slightly improve performance and memory use by allocating the object and control block in one block (saving one allocation) (<a href="https://cpp-core-guidelines-docs.vercel.app/resource#:~:text=,counts%20next%20to%20its%20object">R: Resource management – C++</a>).</p>
<p><strong>Usage example:</strong> Using <code>std::shared_ptr</code> to share an object between multiple owners:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;memory&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Node</span> { <span style="color:#66d9ef">int</span> value; Node(<span style="color:#66d9ef">int</span> v)<span style="color:#f92672">:</span> value(v) {} };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">auto</span> sp1 <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>make_shared<span style="color:#f92672">&lt;</span>Node<span style="color:#f92672">&gt;</span>(<span style="color:#ae81ff">5</span>);           <span style="color:#75715e">// create shared_ptr owning Node(5)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span>Node<span style="color:#f92672">&gt;</span> sp2 <span style="color:#f92672">=</span> sp1;                <span style="color:#75715e">// sp2 shares ownership of the same Node
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;sp1 use_count = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> sp1.use_count() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;  <span style="color:#75715e">// prints 2 (two owners)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    sp1.reset();                                    <span style="color:#75715e">// drop ownership from sp1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;After resetting sp1, use_count = &#34;</span> 
</span></span><span style="display:flex;"><span>              <span style="color:#f92672">&lt;&lt;</span> sp2.use_count() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;           <span style="color:#75715e">// prints 1 (sp2 is sole owner now)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// Node will be deleted automatically when sp2 goes out of scope (use_count becomes 0).
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>In this example, <code>sp1</code> and <code>sp2</code> are <code>shared_ptr&lt;Node&gt;</code> pointing to the same dynamically allocated <code>Node</code>. We start with <code>sp1</code> and then make <code>sp2</code> a copy of <code>sp1</code>, so they co-own the object (the reference count becomes 2). After calling <code>sp1.reset()</code>, <code>sp1</code> no longer owns the <code>Node</code>, but <code>sp2</code> still does (reference count 1), keeping the object alive. When <code>sp2</code> eventually goes out of scope, the reference count drops to 0 and the <code>Node</code> is freed. This illustrates how <code>shared_ptr</code> enables <strong>multiple owners</strong> for an object and automatically cleans up when the last owner is gone (<a href="https://learn.microsoft.com/en-us/cpp/cpp/smart-pointers-modern-cpp?view=msvc-170#:~:text=%2A%20%60shared_ptr%60%20Reference,memory%3E%60.%20For">Smart pointers (Modern C++) | Microsoft Learn</a>).</p>
<p><strong>Best use cases:</strong> Use <code>std::shared_ptr</code> when you truly need shared ownership semantics – for example, in a graph or tree structure where nodes have multiple parents, in observer patterns or publish-subscribe models where multiple subscribers share access to a data object, or in asynchronous tasks where a worker thread needs to ensure an object stays alive while it&rsquo;s processing. It is also useful when returning dynamically allocated objects from factory functions while still keeping a copy elsewhere. Because <code>shared_ptr</code> ensures the object persists as long as someone needs it, it can simplify memory management in complex scenarios. However, be cautious: shared ownership can sometimes make it harder to reason about exactly when an object gets destroyed, especially if copies of <code>shared_ptr</code> are widely distributed. Always consider whether the sharing is necessary; if not, stick to <code>unique_ptr</code>. And whenever <code>shared_ptr</code> forms cyclical references (e.g., two objects holding <code>shared_ptr</code> to each other), you can leak memory since the reference count may never reach zero – this is where <code>std::weak_ptr</code> comes into play.</p>
<h2 id="stdweak_ptr--non-owning-references-to-shared-objects"><code>std::weak_ptr</code> – Non-owning References to Shared Objects</h2>
<p><code>std::weak_ptr</code> is a companion smart pointer to <code>shared_ptr</code> that holds a <strong>non-owning “weak” reference</strong> to an object managed by a <code>shared_ptr</code> (<a href="https://learn.microsoft.com/en-us/cpp/cpp/smart-pointers-modern-cpp?view=msvc-170#:~:text=%2A%20%60weak_ptr%60%20Special,Instances%20%20and%20%2010">Smart pointers (Modern C++) | Microsoft Learn</a>). Unlike <code>shared_ptr</code>, a <code>weak_ptr</code> does not contribute to the reference count and does not own the object. Its primary purpose is to observe or temporarily use an object without preventing that object from being destroyed. If all the owning <code>shared_ptr</code>s to an object go away, the object can be destroyed even if <code>weak_ptr</code>s still point to it. This property is crucial for breaking reference cycles and for cases where you want to avoid dangling raw pointers.</p>
<p>A <code>weak_ptr</code> is always created from an existing <code>shared_ptr</code> (or another <code>weak_ptr</code>). You cannot directly allocate an object into a <code>weak_ptr</code> – it wouldn’t make sense, because <code>weak_ptr</code> alone cannot own an object. Typical usage is that one part of your code holds a <code>shared_ptr</code> (ownership) and another part holds a <code>weak_ptr</code> “observer”. To access the object from a <code>weak_ptr</code>, you must convert it to <code>shared_ptr</code> first, which is done by calling <code>weak_ptr.lock()</code>. The <code>lock()</code> function returns a new <code>std::shared_ptr</code> to the object <strong>if it still exists</strong>, or a null <code>shared_ptr</code> if the object has already been deleted. This allows the observer to safely attempt access. Before using <code>weak_ptr.lock()</code>, you can also call <code>weak_ptr.expired()</code> to check if the object is gone. In effect, <code>weak_ptr</code> provides a safe way to refer to an object that <em>might</em> no longer be alive, avoiding the classic dangling pointer problem: with raw pointers, one cannot easily know if an object was deleted by someone else, but with <code>weak_ptr</code> you can check (<a href="https://stackoverflow.com/questions/12030650/when-is-stdweak-ptr-useful#:~:text=,lock">c++ - When is std::weak_ptr useful? - Stack Overflow</a>).</p>
<p><strong>Usage example:</strong> Using <code>std::weak_ptr</code> to break a reference cycle and to safely access an object:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;memory&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Owner</span> {
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> data;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">auto</span> sp <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>make_shared<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(<span style="color:#ae81ff">42</span>);
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>weak_ptr<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> wp <span style="color:#f92672">=</span> sp;      <span style="color:#75715e">// wp observes the int managed by sp
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Initially, wp.expired() = &#34;</span> 
</span></span><span style="display:flex;"><span>              <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>boolalpha <span style="color:#f92672">&lt;&lt;</span> wp.expired() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;  <span style="color:#75715e">// false, object is alive
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    sp.reset();  <span style="color:#75715e">// drop the only shared_ptr owner; the int is deleted here
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (wp.expired()) {
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;After resetting sp, wp indicates object is expired.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Attempt to lock the weak_ptr (should yield null because object was destroyed):
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">auto</span> sp2 <span style="color:#f92672">=</span> wp.lock()) {
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Object is still alive: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>sp2 <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Object no longer exists, weak_ptr.lock() returned null.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Output:</p>
<pre tabindex="0"><code>Initially, wp.expired() = false  
After resetting sp, wp indicates object is expired.  
Object no longer exists, weak_ptr.lock() returned null.
</code></pre><p>In this example, <code>sp</code> is a <code>shared_ptr&lt;int&gt;</code> that owns an integer. We create <code>wp</code> as a <code>weak_ptr</code> observing the same integer. Initially, <code>wp.expired()</code> is <code>false</code> because the object is still owned by <code>sp</code>. After we reset <code>sp</code> (destroying the last owning reference to the integer), the object is deleted. Now <code>wp.expired()</code> becomes <code>true</code>, and locking the weak pointer yields a null pointer. This shows how <code>weak_ptr</code> can safely detect that the object is gone. If we had only a raw pointer to the int, it would be dangling at this point with no way to detect it; by contrast, <code>weak_ptr</code> provides a mechanism to check validity (<a href="https://stackoverflow.com/questions/12030650/when-is-stdweak-ptr-useful#:~:text=,lock">c++ - When is std::weak_ptr useful? - Stack Overflow</a>) (<a href="https://stackoverflow.com/questions/12030650/when-is-stdweak-ptr-useful#:~:text=,lock">c++ - When is std::weak_ptr useful? - Stack Overflow</a>).</p>
<p>The most common use of <code>weak_ptr</code> is <strong>to break circular references</strong> in data structures. For instance, imagine a simple scenario of two objects that refer to each other via <code>shared_ptr</code>: Object A holds a <code>shared_ptr</code> to Object B, and Object B holds a <code>shared_ptr</code> to Object A. This creates a reference cycle – each has a count of at least 1 due to the other, so their reference counts never drop to zero, and they will never be freed (a memory leak) unless the cycle is broken manually. By changing one of those <code>shared_ptr</code> references to a <code>weak_ptr</code> (say, B holds a <code>weak_ptr</code> to A or vice versa), you break the ownership cycle: one object is the true owner (shared), and the reverse link is non-owning (weak). Then the owned object can be destroyed properly when the owner’s <code>shared_ptr</code> count goes to zero (<a href="https://cpp-core-guidelines-docs.vercel.app/resource#:~:text=,to%20destroy%20a%20cyclic%20structure">R: Resource management – C++</a>). This technique is vital in complex object graphs like observer patterns, tree parent-child relationships, or caches where objects refer back to their owners. In summary, <code>std::weak_ptr</code> should be used for <strong>non-owning references</strong> to objects managed by <code>shared_ptr</code>. It allows you to safely observe the object’s lifetime without extending it. If you find yourself wanting to use a raw pointer to reference an object that is managed elsewhere by a <code>shared_ptr</code>, consider using a <code>weak_ptr</code> instead for safety.</p>
<h2 id="best-practices-for-dynamic-memory-management-in-modern-c">Best Practices for Dynamic Memory Management in Modern C++</h2>
<p>Effective memory management in C++17 goes beyond just choosing the right smart pointer. It involves adhering to patterns that ensure safe ownership, prevent leaks, and minimise overhead. Here are some best practices and guidelines for using smart pointers and dynamic memory:</p>
<ul>
<li>
<p><strong>Prefer RAII and smart pointers over manual <code>new</code>/<code>delete</code>:</strong> Whenever you allocate dynamic memory, immediately encapsulate it in a smart pointer (<code>unique_ptr</code> or <code>shared_ptr</code>) or a suitable RAII container. This ensures that the memory will be automatically freed even if exceptions are thrown or if functions return early, greatly reducing the chance of leaks (<a href="https://cpp-core-guidelines-docs.vercel.app/resource#:~:text=They%20can%20prevent%20resource%20leaks">R: Resource management – C++</a>). In modern C++, you should rarely see naked <code>new</code> or <code>delete</code> in high-level code – resource-owning raw pointers are strongly discouraged in favour of smart pointers.</p>
</li>
<li>
<p><strong>Use <code>std::unique_ptr</code> as the default owning pointer:</strong> If an object has a single owner, <code>unique_ptr</code> is the simplest and most efficient choice. It clearly signals exclusive ownership and has zero runtime overhead beyond a raw pointer. Prefer <code>unique_ptr</code> unless you explicitly need shared ownership (<a href="https://cpp-core-guidelines-docs.vercel.app/resource#:~:text=">R: Resource management – C++</a>). This makes object lifetime and destruction timing easier to reason about (the object is destroyed when the <code>unique_ptr</code> goes out of scope). For example, use <code>unique_ptr</code> for members that are implementation details of a class, or for managing memory in a function that creates and uses a resource privately.</p>
</li>
<li>
<p><strong>Use <code>std::shared_ptr</code> only when ownership must be shared:</strong> If multiple parts of your program need to hold pointers to the same object and ensure it stays alive as long as any part needs it, then use <code>shared_ptr</code>. But be mindful of the overhead of reference counting and the complexities of shared ownership. Do not gratuitously use <code>shared_ptr</code> for every object – doing so adds unnecessary atomic operations and indirection (<a href="https://cpp-core-guidelines-docs.vercel.app/resource#:~:text=A%20,implicitly%20maintain%20a%20use%20count">R: Resource management – C++</a>). A good practice is to make the decision of using <code>shared_ptr</code> explicit: document why an object has shared ownership. When using <code>shared_ptr</code>, prefer to pass around (const) references to it in function parameters if the function only needs to use the object without prolonging its lifetime; this avoids bumping the refcount unnecessarily.</p>
</li>
<li>
<p><strong>Avoid <strong>reference cycles</strong> and use <code>std::weak_ptr</code> for observers:</strong> Be very careful to avoid situations where <code>shared_ptr</code>s refer to each other in a cycle (directly or indirectly). Such cycles will lead to memory leaks because the reference count will never drop to zero (<a href="https://cpp-core-guidelines-docs.vercel.app/resource#:~:text=,to%20destroy%20a%20cyclic%20structure">R: Resource management – C++</a>). To break cycles, or whenever you have one object observing another without owning it, use <code>weak_ptr</code>. A <code>weak_ptr</code> allows one part of the code to refer to an object without affecting its lifetime. For example, in a parent-child relationship, the parent could hold a <code>shared_ptr</code> to the child, and the child could hold a <code>weak_ptr</code> back to the parent. This way, if the parent is destroyed, the child’s weak reference can detect it and avoid accessing a freed object. Using <code>weak_ptr</code> is also useful in caching scenarios or event listener lists, where you want to drop expired objects automatically. In summary, <strong>use <code>weak_ptr</code> for non-owning pointers to prevent dangling pointer issues (<a href="https://stackoverflow.com/questions/12030650/when-is-stdweak-ptr-useful#:~:text=,lock">c++ - When is std::weak_ptr useful? - Stack Overflow</a>) and to break reference cycles</strong>.</p>
</li>
<li>
<p><strong>Prefer <code>std::make_unique</code> and <code>std::make_shared</code> for creation:</strong> When creating smart pointers, use the factory functions <code>std::make_unique&lt;T&gt;(...)</code> and <code>std::make_shared&lt;T&gt;(...)</code> instead of calling <code>new</code> directly. These functions not only make the code more concise and clear (no need to repeat the type <code>T</code> on both sides) but also provide efficiency and exception-safety benefits (<a href="https://cpp-core-guidelines-docs.vercel.app/resource#:~:text=">R: Resource management – C++</a>) (<a href="https://cpp-core-guidelines-docs.vercel.app/resource#:~:text=,counts%20next%20to%20its%20object">R: Resource management – C++</a>). <code>make_shared</code> in particular allocates the object and the control block in one contiguous block of memory, which reduces allocation overhead and can improve cache locality (<a href="https://cpp-core-guidelines-docs.vercel.app/resource#:~:text=,counts%20next%20to%20its%20object">R: Resource management – C++</a>). It also avoids certain potential memory leaks in complex expressions by ensuring that the object is constructed and owned by the smart pointer in one step. Similarly, <code>make_unique</code> was added in C++14 to safely construct a <code>unique_ptr</code> without risking leaks in case of exceptions. Always prefer these over raw <code>new</code>. In C++17, <code>auto ptr = std::make_unique&lt;Foo&gt;(args...);</code> is the recommended idiom for constructing a <code>unique_ptr</code> to a new <code>Foo</code>.</p>
</li>
<li>
<p><strong>Don’t mix owning raw pointers with smart pointers:</strong> Once a raw pointer is managed by a smart pointer, let the smart pointer be the sole owner. Do not manually <code>delete</code> a raw pointer that is held by a smart pointer – this will likely cause a double deletion when the smart pointer tries to delete in its destructor. Likewise, avoid scenarios where you have some raw pointers and some smart pointers referencing the same object; this can lead to confusion about who owns the object and when it gets deleted. If you need to give an existing raw pointer to a smart pointer (say, to transfer ownership), use <code>std::move</code> into a <code>unique_ptr</code> or assign to a <code>shared_ptr</code> and then <strong>do not use</strong> the raw pointer again. In essence, maintain clear ownership: either an object is managed by smart pointers, or it’s managed manually, but not both. A related best practice is to use <code>std::weak_ptr</code> (or raw pointers marked as observers) for any non-owning references, rather than sharing ownership arbitrarily.</p>
</li>
<li>
<p><strong>Be mindful of performance and memory overhead:</strong> Smart pointers greatly reduce the risk of leaks and errors, but they are not free in terms of performance. If you have a performance-critical section, minimise operations that bump reference counts on <code>shared_ptr</code>. Consider passing <code>shared_ptr</code> by reference to avoid atomic increments when appropriate. Also, be aware that every <code>shared_ptr</code> allocation typically involves at least two memory allocations (unless using <code>make_shared</code>): one for the object and one for the control block. In tight memory scenarios or for very small objects, this overhead might be significant. Using <code>make_shared</code> alleviates some of this by combining allocations (<a href="https://cpp-core-guidelines-docs.vercel.app/resource#:~:text=,counts%20next%20to%20its%20object">R: Resource management – C++</a>). For <code>unique_ptr</code>, the overhead is minimal, but remember that creating and destroying many small objects can still be costly due to the underlying <code>new</code>/<code>delete</code>. In such cases, pooling or other allocation strategies might be worth considering, but those are advanced topics beyond the scope of this article. For most use cases, smart pointers hit a good balance of safety and performance.</p>
</li>
<li>
<p><strong>Use smart pointers to express ownership semantics clearly:</strong> The choice between <code>unique_ptr</code>, <code>shared_ptr</code>, or <code>weak_ptr</code> should be guided by ownership semantics in your design. By using the appropriate smart pointer, you make the code’s intent clear. Reviewers and future maintainers can tell at a glance whether a function takes ownership of a resource (e.g., a function accepting a <code>unique_ptr</code> is explicitly saying it will take over ownership), or whether a class shares ownership of a resource (<code>shared_ptr</code>) or just observes it (<code>weak_ptr</code>). Leverage this to write self-documenting interfaces. The C++ Core Guidelines, for example, encourage using smart pointer types in function signatures to make lifetime expectations explicit (only pass a smart pointer by value if you intend to share/transfer ownership) (<a href="https://cpp-core-guidelines-docs.vercel.app/resource#:~:text=R,to%20explicitly%20express%20lifetime%20semantics">R: Resource management – C++</a>) (<a href="https://cpp-core-guidelines-docs.vercel.app/resource#:~:text=Any%20type%20,is%20considered%20a%20smart%20pointer">R: Resource management – C++</a>).</p>
</li>
<li>
<p><strong>Consider object lifetime and scope</strong> before using dynamic allocation at all: As a final thought, remember that not everything needs to be on the heap. Often, objects can be allocated with automatic storage duration (on the stack) or as members of other objects or containers, which avoids dynamic allocation altogether. This isn’t a rule about smart pointers per se, but a general memory management tip: prefer the simplest ownership model that meets your needs. If a resource doesn’t need to outlive the scope of a function, a local variable is best. If you need a growable array or collection of objects, a standard container like <code>std::vector</code> manages memory for you. Use dynamic allocation (and hence smart pointers) when you truly need flexible lifetime or polymorphic behaviour that requires heap allocation. When you do, the smart pointers are there to help you manage that lifetime safely.</p>
</li>
</ul>
<h2 id="conclusion-and-future-considerations">Conclusion and Future Considerations</h2>
<p>C++17 smart pointers (<code>unique_ptr</code>, <code>shared_ptr</code>, and <code>weak_ptr</code>) provide robust facilities for automatic memory management, helping developers write safer and more maintainable code. By expressing ownership explicitly, they eliminate most common causes of memory leaks and dangling pointers, while also clarifying how resources are passed around in your program. To recap: <strong><code>std::unique_ptr</code></strong> offers fast and exclusive ownership for singly-owned resources, <strong><code>std::shared_ptr</code></strong> offers flexible shared ownership with reference-counting (use it only when needed), and <strong><code>std::weak_ptr</code></strong> offers a way to observe or reference a <code>shared_ptr</code>-managed object without extending its lifetime, which is essential for breaking cycles and preventing leaks. Using these smart pointers in adherence to RAII principles means that resources are acquired and released in a well-defined manner, greatly reducing the cognitive load of manual memory management.</p>
<p>In C++17, these smart pointers are mature and well-tested. Going forward, the C++ standard and community continue to refine memory management techniques. For example, C++20 introduced improvements like atomic support for <code>shared_ptr</code> operations to aid concurrency, and there are proposals for new smart pointer types or utilities (such as <code>std::observer_ptr</code> for non-owning raw pointer wrappers, in the Library Fundamentals TS). Tools like sanitizers and static analyzers are increasingly used to catch memory errors that smart pointers can’t prevent (such as buffer overruns or misuse of unowned raw pointers). Nonetheless, the fundamental advice remains: <strong>prefer RAII and smart pointers for dynamic memory</strong>. By following best practices – choosing the right smart pointer for the job, avoiding raw <code>new/delete</code>, and designing with clear ownership in mind – you can largely eliminate memory leaks and many classes of errors in C++ code (<a href="https://cpp-core-guidelines-docs.vercel.app/resource#:~:text=They%20can%20prevent%20resource%20leaks">R: Resource management – C++</a>). In summary, smart pointers are a key component of modern C++ memory management, enabling developers to write code that is both safer and easier to understand, without sacrificing performance or control. With disciplined use of <code>unique_ptr</code>, <code>shared_ptr</code>, and <code>weak_ptr</code>, intermediate and advanced developers can master memory management in C++17 and beyond, laying a strong foundation for building reliable software.</p>
<p><strong>Sources:</strong></p>
<ul>
<li>C++ Core Guidelines (R.20, R.21, R.22, R.23, R.24) – Rules and rationale for using smart pointers and RAII (<a href="https://cpp-core-guidelines-docs.vercel.app/resource#:~:text=They%20can%20prevent%20resource%20leaks">R: Resource management – C++</a>) (<a href="https://cpp-core-guidelines-docs.vercel.app/resource#:~:text=">R: Resource management – C++</a>) (<a href="https://cpp-core-guidelines-docs.vercel.app/resource#:~:text=,counts%20next%20to%20its%20object">R: Resource management – C++</a>) (<a href="https://cpp-core-guidelines-docs.vercel.app/resource#:~:text=">R: Resource management – C++</a>) (<a href="https://cpp-core-guidelines-docs.vercel.app/resource#:~:text=,to%20destroy%20a%20cyclic%20structure">R: Resource management – C++</a>).</li>
<li>Microsoft Docs – <em>Smart pointers (Modern C++)</em> – Descriptions of <code>unique_ptr</code>, <code>shared_ptr</code>, <code>weak_ptr</code> and their use cases (<a href="https://learn.microsoft.com/en-us/cpp/cpp/smart-pointers-modern-cpp?view=msvc-170#:~:text=,and%20Use%20unique_ptr%20Instances%20and">Smart pointers (Modern C++) | Microsoft Learn</a>) (<a href="https://learn.microsoft.com/en-us/cpp/cpp/smart-pointers-modern-cpp?view=msvc-170#:~:text=%2A%20%60shared_ptr%60%20Reference,memory%3E%60.%20For">Smart pointers (Modern C++) | Microsoft Learn</a>) (<a href="https://learn.microsoft.com/en-us/cpp/cpp/smart-pointers-modern-cpp?view=msvc-170#:~:text=%2A%20%60weak_ptr%60%20Special,Instances%20%20and%20%2010">Smart pointers (Modern C++) | Microsoft Learn</a>).</li>
<li>cppreference – Documentation of <a href="https://en.cppreference.com/w/cpp/memory/unique_ptr"><code>std::unique_ptr</code></a>, <a href="https://en.cppreference.com/w/cpp/memory/shared_ptr"><code>std::shared_ptr</code></a>, and <a href="https://en.cppreference.com/w/cpp/memory/weak_ptr"><code>std::weak_ptr</code></a> (accessed for behavioural details).</li>
<li>Stack Overflow – Discussion on when <code>std::weak_ptr</code> is useful, illustrating the dangling pointer problem and how <code>weak_ptr</code> addresses it (<a href="https://stackoverflow.com/questions/12030650/when-is-stdweak-ptr-useful#:~:text=,lock">c++ - When is std::weak_ptr useful? - Stack Overflow</a>) (<a href="https://stackoverflow.com/questions/12030650/when-is-stdweak-ptr-useful#:~:text=,lock">c++ - When is std::weak_ptr useful? - Stack Overflow</a>).</li>
</ul>

      </div>
    </article>

    <hr />

    <div class="post-info">
      
    <p>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7" y2="7"></line></svg>

        <span class="tag"><a href="https://blog.miguens.one/tags/c_cpp/">c_cpp</a></span>
        <span class="tag"><a href="https://blog.miguens.one/tags/programming/">programming</a></span>
        
    </p>

      
    <p>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-folder meta-icon"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path></svg>

        <span class="tag"><a href="https://blog.miguens.one/categories/technical/">technical</a></span>
        
    </p>


      <p>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text">
          <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
          <polyline points="14 2 14 8 20 8"></polyline>
          <line x1="16" y1="13" x2="8" y2="13"></line>
          <line x1="16" y1="17" x2="8" y2="17"></line>
          <polyline points="10 9 9 9 8 9"></polyline>
        </svg>
        4207 Words
      </p>

      <p>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar">
          <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
          <line x1="16" y1="2" x2="16" y2="6"></line>
          <line x1="8" y1="2" x2="8" y2="6"></line>
          <line x1="3" y1="10" x2="21" y2="10"></line>
        </svg>
        
          2025-03-07
        

         
          
        
      </p>
    </div>
      <hr />
      <div class="sharing-buttons">
        
<a class="resp-sharing-button__link" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fblog.miguens.one%2fposts%2f2025%2f03%2fsmart-pointers-and-memory-management-in-c-17%2f" target="_blank" rel="noopener" aria-label="" title="Share on facebook">
  <div class="resp-sharing-button resp-sharing-button--facebook resp-sharing-button--small"><div aria-hidden="true" class="resp-sharing-button__icon resp-sharing-button__icon--solid">
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 2h-3a5 5 0 0 0-5 5v3H7v4h3v8h4v-8h3l1-4h-4V7a1 1 0 0 1 1-1h3z"></path></svg>
    </div>
  </div>
</a>


<a class="resp-sharing-button__link" href="https://twitter.com/intent/tweet/?url=https%3a%2f%2fblog.miguens.one%2fposts%2f2025%2f03%2fsmart-pointers-and-memory-management-in-c-17%2f" target="_blank" rel="noopener" aria-label="" title="Share on twitter">
  <div class="resp-sharing-button resp-sharing-button--twitter resp-sharing-button--small">
      <div aria-hidden="true" class="resp-sharing-button__icon resp-sharing-button__icon--solid">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"></path></svg>
    </div>
  </div>
</a>


<a class="resp-sharing-button__link" href="https://www.tumblr.com/widgets/share/tool?posttype=link&amp;title=Smart%20Pointers%20and%20Memory%20Management%20in%20C%2b%2b17&amp;caption=Smart%20Pointers%20and%20Memory%20Management%20in%20C%2b%2b17&amp;canonicalUrl=https%3a%2f%2fblog.miguens.one%2fposts%2f2025%2f03%2fsmart-pointers-and-memory-management-in-c-17%2f" target="_blank" rel="noopener" aria-label="" title="Share on tumblr">
  <div class="resp-sharing-button resp-sharing-button--tumblr resp-sharing-button--small">
    <div aria-hidden="true" class="resp-sharing-button__icon resp-sharing-button__icon--solid">
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor" stroke="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14.563 24c-5.093 0-7.031-3.756-7.031-6.411V9.747H5.116V6.648c3.63-1.313 4.512-4.596 4.71-6.469C9.84.051 9.941 0 9.999 0h3.517v6.114h4.801v3.633h-4.82v7.47c.016 1.001.375 2.371 2.207 2.371h.09c.631-.02 1.486-.205 1.936-.419l1.156 3.425c-.436.636-2.4 1.374-4.156 1.404h-.178l.011.002z"/></svg>
    </div>
  </div>
</a>


<a class="resp-sharing-button__link" href="mailto:?subject=Smart%20Pointers%20and%20Memory%20Management%20in%20C%2b%2b17&amp;body=https%3a%2f%2fblog.miguens.one%2fposts%2f2025%2f03%2fsmart-pointers-and-memory-management-in-c-17%2f" target="_self" rel="noopener" aria-label="" title="Share via email">
  <div class="resp-sharing-button resp-sharing-button--email resp-sharing-button--small"><div aria-hidden="true" class="resp-sharing-button__icon resp-sharing-button__icon--solid">
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path><polyline points="22,6 12,13 2,6"></polyline></svg>
    </div>
  </div>
</a>


<a class="resp-sharing-button__link" href="https://pinterest.com/pin/create/button/?url=https%3a%2f%2fblog.miguens.one%2fposts%2f2025%2f03%2fsmart-pointers-and-memory-management-in-c-17%2f&amp;media=https%3a%2f%2fblog.miguens.one%2fposts%2f2025%2f03%2fsmart-pointers-and-memory-management-in-c-17%2f;description=Smart%20Pointers%20and%20Memory%20Management%20in%20C%2b%2b17" target="_blank" rel="noopener" aria-label="" title="Share on pinterest">
  <div class="resp-sharing-button resp-sharing-button--pinterest resp-sharing-button--small"><div aria-hidden="true" class="resp-sharing-button__icon resp-sharing-button__icon--solid">
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor" stroke="none"><path d="M12.017 0C5.396 0 .029 5.367.029 11.987c0 5.079 3.158 9.417 7.618 11.162-.105-.949-.199-2.403.041-3.439.219-.937 1.406-5.957 1.406-5.957s-.359-.72-.359-1.781c0-1.663.967-2.911 2.168-2.911 1.024 0 1.518.769 1.518 1.688 0 1.029-.653 2.567-.992 3.992-.285 1.193.6 2.165 1.775 2.165 2.128 0 3.768-2.245 3.768-5.487 0-2.861-2.063-4.869-5.008-4.869-3.41 0-5.409 2.562-5.409 5.199 0 1.033.394 2.143.889 2.741.099.12.112.225.085.345-.09.375-.293 1.199-.334 1.363-.053.225-.172.271-.401.165-1.495-.69-2.433-2.878-2.433-4.646 0-3.776 2.748-7.252 7.92-7.252 4.158 0 7.392 2.967 7.392 6.923 0 4.135-2.607 7.462-6.233 7.462-1.214 0-2.354-.629-2.758-1.379l-.749 2.848c-.269 1.045-1.004 2.352-1.498 3.146 1.123.345 2.306.535 3.55.535 6.607 0 11.985-5.365 11.985-11.987C23.97 5.39 18.592.026 11.985.026L12.017 0z"/></svg>
    </div>
  </div>
</a>


<a class="resp-sharing-button__link" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fblog.miguens.one%2fposts%2f2025%2f03%2fsmart-pointers-and-memory-management-in-c-17%2f&amp;title=Smart%20Pointers%20and%20Memory%20Management%20in%20C%2b%2b17&amp;summary=Smart%20Pointers%20and%20Memory%20Management%20in%20C%2b%2b17&amp;source=https%3a%2f%2fblog.miguens.one%2fposts%2f2025%2f03%2fsmart-pointers-and-memory-management-in-c-17%2f" target="_blank" rel="noopener" aria-label="" title="Share on linkedin">
  <div class="resp-sharing-button resp-sharing-button--linkedin resp-sharing-button--small"><div aria-hidden="true" class="resp-sharing-button__icon resp-sharing-button__icon--solid">
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2 2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6z"></path><rect x="2" y="9" width="4" height="12"></rect><circle cx="4" cy="4" r="2"></circle></svg>
    </div>
  </div>
</a>


<a class="resp-sharing-button__link" href="https://reddit.com/submit/?url=https%3a%2f%2fblog.miguens.one%2fposts%2f2025%2f03%2fsmart-pointers-and-memory-management-in-c-17%2f&amp;resubmit=true&amp;title=Smart%20Pointers%20and%20Memory%20Management%20in%20C%2b%2b17" target="_blank" rel="noopener" aria-label="" title="Share on reddit">
  <div class="resp-sharing-button resp-sharing-button--reddit resp-sharing-button--small"><div aria-hidden="true" class="resp-sharing-button__icon resp-sharing-button__icon--solid">
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor" stroke="none"><path d="M12 0A12 12 0 0 0 0 12a12 12 0 0 0 12 12 12 12 0 0 0 12-12A12 12 0 0 0 12 0zm5.01 4.744c.688 0 1.25.561 1.25 1.249a1.25 1.25 0 0 1-2.498.056l-2.597-.547-.8 3.747c1.824.07 3.48.632 4.674 1.488.308-.309.73-.491 1.207-.491.968 0 1.754.786 1.754 1.754 0 .716-.435 1.333-1.01 1.614a3.111 3.111 0 0 1 .042.52c0 2.694-3.13 4.87-7.004 4.87-3.874 0-7.004-2.176-7.004-4.87 0-.183.015-.366.043-.534A1.748 1.748 0 0 1 4.028 12c0-.968.786-1.754 1.754-1.754.463 0 .898.196 1.207.49 1.207-.883 2.878-1.43 4.744-1.487l.885-4.182a.342.342 0 0 1 .14-.197.35.35 0 0 1 .238-.042l2.906.617a1.214 1.214 0 0 1 1.108-.701zM9.25 12C8.561 12 8 12.562 8 13.25c0 .687.561 1.248 1.25 1.248.687 0 1.248-.561 1.248-1.249 0-.688-.561-1.249-1.249-1.249zm5.5 0c-.687 0-1.248.561-1.248 1.25 0 .687.561 1.248 1.249 1.248.688 0 1.249-.561 1.249-1.249 0-.687-.562-1.249-1.25-1.249zm-5.466 3.99a.327.327 0 0 0-.231.094.33.33 0 0 0 0 .463c.842.842 2.484.913 2.961.913.477 0 2.105-.056 2.961-.913a.361.361 0 0 0 .029-.463.33.33 0 0 0-.464 0c-.547.533-1.684.73-2.512.73-.828 0-1.979-.196-2.512-.73a.326.326 0 0 0-.232-.095z"/></svg>
    </div>
  </div>
</a>


<a class="resp-sharing-button__link" href="https://www.xing.com/app/user?op=share;url=https%3a%2f%2fblog.miguens.one%2fposts%2f2025%2f03%2fsmart-pointers-and-memory-management-in-c-17%2f;title=Smart%20Pointers%20and%20Memory%20Management%20in%20C%2b%2b17" target="_blank" rel="noopener" aria-label="" title="Share on xing">
  <div class="resp-sharing-button resp-sharing-button--xing resp-sharing-button--small"><div aria-hidden="true" class="resp-sharing-button__icon resp-sharing-button__icon--solid">
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor" stroke="none"><path d="M18.188 0c-.517 0-.741.325-.927.66 0 0-7.455 13.224-7.702 13.657.015.024 4.919 9.023 4.919 9.023.17.308.436.66.967.66h3.454c.211 0 .375-.078.463-.22.089-.151.089-.346-.009-.536l-4.879-8.916c-.004-.006-.004-.016 0-.022L22.139.756c.095-.191.097-.387.006-.535C22.056.078 21.894 0 21.686 0h-3.498zM3.648 4.74c-.211 0-.385.074-.473.216-.09.149-.078.339.02.531l2.34 4.05c.004.01.004.016 0 .021L1.86 16.051c-.099.188-.093.381 0 .529.085.142.239.234.45.234h3.461c.518 0 .766-.348.945-.667l3.734-6.609-2.378-4.155c-.172-.315-.434-.659-.962-.659H3.648v.016z"/></svg>
    </div>
  </div>
</a>


<a class="resp-sharing-button__link" href="whatsapp://send?text=Smart%20Pointers%20and%20Memory%20Management%20in%20C%2b%2b17%20https%3a%2f%2fblog.miguens.one%2fposts%2f2025%2f03%2fsmart-pointers-and-memory-management-in-c-17%2f" target="_blank" rel="noopener" aria-label="" title="Share on whatsapp">
  <div class="resp-sharing-button resp-sharing-button--whatsapp resp-sharing-button--small"><div aria-hidden="true" class="resp-sharing-button__icon resp-sharing-button__icon--solid">
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor" stroke="none" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"><path d="M17.472 14.382c-.297-.149-1.758-.867-2.03-.967-.273-.099-.471-.148-.67.15-.197.297-.767.966-.94 1.164-.173.199-.347.223-.644.075-.297-.15-1.255-.463-2.39-1.475-.883-.788-1.48-1.761-1.653-2.059-.173-.297-.018-.458.13-.606.134-.133.298-.347.446-.52.149-.174.198-.298.298-.497.099-.198.05-.371-.025-.52-.075-.149-.669-1.612-.916-2.207-.242-.579-.487-.5-.669-.51-.173-.008-.371-.01-.57-.01-.198 0-.52.074-.792.372-.272.297-1.04 1.016-1.04 2.479 0 1.462 1.065 2.875 1.213 3.074.149.198 2.096 3.2 5.077 4.487.709.306 1.262.489 1.694.625.712.227 1.36.195 1.871.118.571-.085 1.758-.719 2.006-1.413.248-.694.248-1.289.173-1.413-.074-.124-.272-.198-.57-.347m-5.421 7.403h-.004a9.87 9.87 0 01-5.031-1.378l-.361-.214-3.741.982.998-3.648-.235-.374a9.86 9.86 0 01-1.51-5.26c.001-5.45 4.436-9.884 9.888-9.884 2.64 0 5.122 1.03 6.988 2.898a9.825 9.825 0 012.893 6.994c-.003 5.45-4.437 9.884-9.885 9.884m8.413-18.297A11.815 11.815 0 0012.05 0C5.495 0 .16 5.335.157 11.892c0 2.096.547 4.142 1.588 5.945L.057 24l6.305-1.654a11.882 11.882 0 005.683 1.448h.005c6.554 0 11.89-5.335 11.893-11.893a11.821 11.821 0 00-3.48-8.413Z"/></svg>
    </div>
  </div>
</a>


<a class="resp-sharing-button__link" href="https://news.ycombinator.com/submitlink?u=https%3a%2f%2fblog.miguens.one%2fposts%2f2025%2f03%2fsmart-pointers-and-memory-management-in-c-17%2f&amp;t=Smart%20Pointers%20and%20Memory%20Management%20in%20C%2b%2b17" target="_blank" rel="noopener" aria-label="" title="Share on hacker news">
  <div class="resp-sharing-button resp-sharing-button--hackernews resp-sharing-button--small"><div aria-hidden="true" class="resp-sharing-button__icon resp-sharing-button__icon--solid">
			<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor" stroke="none"><path d="M0 24V0h24v24H0zM6.951 5.896l4.112 7.708v5.064h1.583v-4.972l4.148-7.799h-1.749l-2.457 4.875c-.372.745-.688 1.434-.688 1.434s-.297-.708-.651-1.434L8.831 5.896h-1.88z"/></svg>
    </div>
  </div>
</a>


<a class="resp-sharing-button__link" href="https://telegram.me/share/url?text=Smart%20Pointers%20and%20Memory%20Management%20in%20C%2b%2b17&amp;url=https%3a%2f%2fblog.miguens.one%2fposts%2f2025%2f03%2fsmart-pointers-and-memory-management-in-c-17%2f" target="_blank" rel="noopener" aria-label="" title="Share on telegram">
  <div class="resp-sharing-button resp-sharing-button--telegram resp-sharing-button--small"><div aria-hidden="true" class="resp-sharing-button__icon resp-sharing-button__icon--solid">
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="22" y1="2" x2="11" y2="13"></line><polygon points="22 2 15 22 11 13 2 9 22 2"></polygon></svg>
    </div>
  </div>
</a>

      </div>

    
    <div class="pagination">
        

        <div class="pagination__buttons">
            
            <span class="button previous">
                <a href="https://blog.miguens.one/posts/2025/04/concurrency-and-multithreading-in-c-17/">
                    <span class="button__icon">←</span>
                    <span class="button__text">Concurrency and Multithreading in C&#43;&#43;17</span>
                </a>
            </span>
            

            
            <span class="button next">
                <a href="https://blog.miguens.one/posts/2025/02/a-comprehensive-examination-of-exception-handling-in-c-17/">
                    <span class="button__text">A Comprehensive Examination of Exception Handling in C&#43;&#43;17</span>
                    <span class="button__icon">→</span>
                </a>
            </span>
            
        </div>
    </div>


    

    

    

  </main>

            </div>

            
                <footer class="footer">
    
    
</footer>

            
        </div>

        



<script type="text/javascript" src="https://blog.miguens.one/bundle.min.ad54ad97364f77ede35def9096b162bb1f0b3973aa50b080f5e82fa147f6882e2a7200d7535adbf9b51bebf939f1c1ca9bbe6be87530092aca720eac4a226fda.js" integrity="sha512-rVStlzZPd&#43;3jXe&#43;QlrFiux8LOXOqULCA9egvoUf2iC4qcgDXU1rb&#43;bUb6/k58cHKm75r6HUwCSrKcg6sSiJv2g=="></script>




    </body>
</html>
